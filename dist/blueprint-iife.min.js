var blueprint = (function (exports) {
  'use strict';

  const map = '123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
  function uuid() {
      let ranStr = '';
      for (let i = 0; i < 19; i++) {
          ranStr += map[Math.floor(Math.random() * (48 + 9))];
      }
      return ranStr + new Date().getTime();
  }

  var ClassType;
  (function (ClassType) {
      ClassType["LINE"] = "Line";
      ClassType["NODE"] = "Node";
      ClassType["PARAM"] = "Param";
  })(ClassType || (ClassType = {}));

  class BaseNode {
      constructor() {
          this.classType = ClassType.NODE;
          this.inputPoints = [];
          this.outPutPoints = [];
          this.variables = {};
          this.nodeName = 'Function Name';
          this.nodeType = 'Function';
          this._nodeLabel = '';
          this.nodeBaseWidth = 250;
          this.nodeId = uuid();
          this.async = false;
          this._x = 0;
          this._y = 0;
          this.preNodeRequired = true;
          this.nextNodeRequired = true;
          this.yAxisPak = 10;
          this.preNodes = [];
          this.nextNodes = [];
          this.preLines = [];
          this.nextLines = [];
      }
      execute() {
          this.func(this.inputPoints, this.outPutPoints);
          this.nextNodes.forEach((item) => {
              item.execute();
          });
      }
      getPrePointPosition() {
          return [this._x + 10, this._y + 32 + 10 + 5];
      }
      getNextPointPosition() {
          return [this._x + 250 - 10, this._y + 32 + 10 + 5];
      }
      getParamPosition(index, isInput = true) {
          if (isInput) {
              return [this._x + 10, this._y + 32 + 25 + 20 * index + this.yAxisPak];
          }
          else {
              return [this._x + 250, this._y + 32 + 25 + 20 * index + this.yAxisPak];
          }
      }
  }

  class Point {
      constructor(x, y) {
          this.x = x;
          this.y = y;
      }
      middileWith(p) {
          const mx = (this.x + p.x) / 2;
          const my = (this.y + p.y) / 2;
          return new Point(mx, my);
      }
      distanceWith(p) {
          return Math.pow((p.x - this.x) * (p.x - this.x) + (p.y - this.y) * (p.y - this.y), 0.5);
      }
  }

  class IO {
      constructor() { }
      static on(eventName, listener, options = {}) {
          if (eventName === undefined || listener === undefined) {
              console.error('event or listener is required!');
              return;
          }
          if (!(eventName in this._events)) {
              this._events[eventName] = [];
          }
          if (this._events[eventName].length >= this.MAX_LISTENERS) {
              console.error(`${eventName}'s number of listeners has reached the limit`);
              return;
          }
          if (options.only) {
              if (this._events[eventName].length !== 0) {
                  return;
              }
          }
          this._events[eventName].push({
              handler: listener,
              once: options.once != undefined ? options.once : false,
          });
      }
      static emit(eventName, ...args) {
          if (!(eventName in this._events)) {
              return false;
          }
          const listeners = this._events[eventName];
          try {
              listeners.forEach((eventTarget) => {
                  eventTarget.handler(...args);
                  if (eventTarget.once) {
                      this.removeListener(eventName, eventTarget.handler);
                  }
              });
          }
          catch (error) {
              console.error(error);
          }
      }
      static once(eventName, listener) {
          this.on(eventName, listener, { once: true });
      }
      static off(eventName, listener) {
          this.removeListener(eventName, listener);
      }
      static removeListener(eventName, listener) {
          if (!(eventName in this._events)) {
              console.warn(`there is no event named ${eventName}`);
              return false;
          }
          let listenerIndex = null;
          for (let i = 0, l = this._events[eventName].length; i < l; i++) {
              if (this._events[eventName][i].handler === listener) {
                  listenerIndex = i;
                  break;
              }
          }
          if (listenerIndex !== null) {
              this._events[eventName].splice(listenerIndex, 1);
          }
      }
      static removeAllListener(eventName) {
          if (this._events[eventName] === undefined) {
              console.warn(`there is no event named ${eventName}`);
              return false;
          }
          this._events[eventName] = [];
      }
      static setMaxListeners(num) {
          this.MAX_LISTENERS = num;
      }
      static clear() {
          this._events = Object.create(null);
      }
  }
  IO._events = Object.create(null);
  IO.MAX_LISTENERS = 30;

  const createDom = (tag) => {
      return document.createElement(tag);
  };
  const createDiv = () => {
      return createDom('div');
  };
  const createSvg = (tag) => {
      return document.createElementNS('http://www.w3.org/2000/svg', tag);
  };
  const createInputNumberBox = () => {
      const input = document.createElement('input');
      input.setAttribute('type', 'number');
      return input;
  };
  const createInputTextBox = () => {
      const input = document.createElement('input');
      input.setAttribute('type', 'text');
      return input;
  };
  const createSpan = () => {
      return createDom('span');
  };
  const createCheckBox = () => {
      const input = document.createElement('input');
      input.setAttribute('type', 'checkbox');
      return input;
  };

  /**
   * Common utilities
   * @module glMatrix
   */
  var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
  if (!Math.hypot) Math.hypot = function () {
    var y = 0,
        i = arguments.length;

    while (i--) {
      y += arguments[i] * arguments[i];
    }

    return Math.sqrt(y);
  };

  /**
   * Multiplies two mat3's
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the first operand
   * @param {ReadonlyMat3} b the second operand
   * @returns {mat3} out
   */

  function multiply(out, a, b) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    var b00 = b[0],
        b01 = b[1],
        b02 = b[2];
    var b10 = b[3],
        b11 = b[4],
        b12 = b[5];
    var b20 = b[6],
        b21 = b[7],
        b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }

  /**
   * 2 Dimensional Vector
   * @module vec2
   */

  /**
   * Creates a new, empty vec2
   *
   * @returns {vec2} a new 2D vector
   */

  function create() {
    var out = new ARRAY_TYPE(2);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }

    return out;
  }
  /**
   * Transforms the vec2 with a mat3
   * 3rd vector component is implicitly '1'
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the vector to transform
   * @param {ReadonlyMat3} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat3(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
  }
  /**
   * Perform some operation over an array of vec2s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  (function () {
    var vec = create();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 2;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
      }

      return a;
    };
  })();

  class Selector {
      constructor() {
          this.isHidden = true;
          this.create();
      }
      create() {
          const container = createSvg('svg');
          container.style.position = 'absolute';
          container.style.opacity = '0.5';
          container.style.display = 'none';
          const rec = createSvg('rect');
          rec.setAttribute('width', '0');
          rec.setAttribute('height', '0');
          rec.setAttribute('stroke', '#5352ed');
          rec.setAttribute('stroke-width', '4px');
          rec.setAttribute('fill', '#70a1ff');
          this.inside = rec;
          container.appendChild(rec);
          this.instance = container;
          document.body.appendChild(container);
      }
      update(x, y, width, height) {
          if (width >= 0 && height >= 0) {
              this.instance.style.left = x + 'px';
              this.instance.style.top = y + 'px';
              this.x = x;
              this.y = y;
          }
          if (width < 0 && height < 0) {
              this.instance.style.left = x + width + 'px';
              this.instance.style.top = y + height + 'px';
              this.x = x + width;
              this.y = y + height;
          }
          if (width > 0 && height < 0) {
              this.instance.style.left = x + 'px';
              this.instance.style.top = y + height + 'px';
              this.x = x;
              this.y = y + height;
          }
          if (width < 0 && height > 0) {
              this.instance.style.left = x + width + 'px';
              this.instance.style.top = y + 'px';
              this.x = x + width;
              this.y = y;
          }
          this.instance.style.width = Math.abs(width) + 'px';
          this.instance.style.height = Math.abs(height) + 'px';
          this.width = Math.abs(width);
          this.height = Math.abs(height);
          this.inside.setAttribute('width', `${Math.abs(width)}`);
          this.inside.setAttribute('height', `${Math.abs(height)}`);
      }
      show() {
          this.instance.style.display = 'block';
          this.isHidden = false;
      }
      hidden() {
          this.update(0, 0, 0, 0);
          this.instance.style.display = 'none';
          this.isHidden = true;
      }
  }

  var Os;
  (function (Os) {
      Os["Windows"] = "Windows";
      Os["Mac"] = "Mac";
      Os["Linux"] = "Linux";
  })(Os || (Os = {}));

  const intersection_rectangle = (x, y, width, height, x2, y2, width2, height2) => {
      const centerX = x + width / 2;
      const centerY = y + height / 2;
      const centerX2 = x2 + width2 / 2;
      const centerY2 = y2 + height2 / 2;
      const x_axis_projection = Math.abs(centerX2 - centerX);
      const y_axis_projection = Math.abs(centerY2 - centerY);
      if ((width + width2) / 2 > x_axis_projection &&
          (height + height2) / 2 > y_axis_projection) {
          return true;
      }
      return false;
  };

  var NodeConnectType;
  (function (NodeConnectType) {
      NodeConnectType[NodeConnectType["PRE"] = 0] = "PRE";
      NodeConnectType[NodeConnectType["NEXT"] = 1] = "NEXT";
  })(NodeConnectType || (NodeConnectType = {}));
  class BaseLine {
      constructor() {
          this.classType = ClassType.LINE;
          this._color = 'white';
          this.id = uuid();
      }
      _getControlPoint(begin, end) {
          const middlePoint = begin.middileWith(end);
          if (begin.x < end.x) {
              return [middlePoint.x, begin.y, middlePoint.x, end.y];
          }
          else {
              return [
                  begin.x + begin.x - middlePoint.x,
                  begin.y,
                  end.x - (middlePoint.x - end.x),
                  end.y,
              ];
          }
      }
      _setSize() {
          this._width = Math.abs(this._end.x - this._begin.x);
          this._height = Math.abs(this._end.y - this._begin.y);
      }
  }

  class LogMsg {
  }

  exports.MouseDownType = void 0;
  (function (MouseDownType) {
      MouseDownType[MouseDownType["LEFT"] = 0] = "LEFT";
      MouseDownType[MouseDownType["RIGHT"] = 2] = "RIGHT";
      MouseDownType[MouseDownType["NONE"] = -1] = "NONE";
  })(exports.MouseDownType || (exports.MouseDownType = {}));
  exports.EditorEventType = void 0;
  (function (EditorEventType) {
      EditorEventType["Normal"] = "normal";
      EditorEventType["NodeActive"] = "NodeActive";
      EditorEventType["LineBegin"] = "LineBegin";
      EditorEventType["LineEnd"] = "LineEnd";
  })(exports.EditorEventType || (exports.EditorEventType = {}));
  exports.BeginType = void 0;
  (function (BeginType) {
      BeginType["NODE"] = "node";
      BeginType["PARAM"] = "param";
      BeginType["PROCESS"] = "process";
  })(exports.BeginType || (exports.BeginType = {}));
  class BluePrintEditor {
      constructor(container) {
          this.msgLogger = new LogMsg();
          this.graph = [];
          this.lineGraph = [];
          this.scale = 1;
          this._orginSize = [];
          this._mouseDownType = -1;
          this._mouseDownPosition = [];
          this._translateLast = [0, 0];
          this._transform = {
              translate: [0, 0],
              transformOrigin: '0px 0px',
          };
          this.currentEventType = exports.EditorEventType.Normal;
          IO.emit('beforeCreated');
          IO.on('LineRemove', (id) => {
              const index = this.lineGraph.findIndex((item) => item.id);
              if (index === -1)
                  return;
              const line = this.lineGraph[index];
              this.lineGraph.splice(index, 1);
              line.destory();
          });
          IO.on('NodeActive', (node) => {
              if (this.currentEventType === exports.EditorEventType.LineBegin)
                  return;
              this.NodeActiveHandler(node);
          }, { only: true });
          IO.on('NodeInactive', () => {
              if (this.currentEventType !== exports.EditorEventType.LineBegin) {
                  this.currentEventType = exports.EditorEventType.Normal;
              }
              this.currentTarget = null;
          }, { only: true });
          IO.on('ConnectPointClick', (info) => {
              this.handleConnectPointClick(info);
          }, { only: true });
          IO.on('ParamPointClick', (info) => {
              this.paramPointClickHandler(info);
          }, { only: true });
          IO.on('ProcessPointClick', (info) => {
              this.processPointClickHandler(info);
          }, { only: true });
          IO.on('ConnectPointEnter', (info) => { }, { only: true });
          container.oncontextmenu = function () {
              return false;
          };
          this.container = container;
          this._orginSize[0] = this.container.getClientRects()[0].width;
          this._orginSize[1] = this.container.getClientRects()[0].height;
          container.style.position = 'relative';
          container.style.transform = 'scale(1)';
          this.initLineContainer();
          this.init();
      }
      init() {
          this.container.addEventListener('mousedown', (ev) => {
              this.setMouseDownType(ev.button);
              if (this.onRightClick && ev.button === 2) {
                  this.onRightClick();
              }
              this.recordPosition(ev.clientX, ev.clientY);
          });
          document.body.addEventListener('mouseup', (ev) => {
              this._mouseDownType = -1;
              this._transform.translate = [...this._translateLast];
              this._mouseDownPosition = [];
              this.selector.hidden();
              if (this.currentEventType === exports.EditorEventType.LineBegin) {
                  this.currentLine.destory();
                  this.currentLine = null;
                  this.currentEventType = exports.EditorEventType.Normal;
                  this.resetAfterAttachLine();
              }
          });
          document.body.addEventListener('mousemove', (ev) => {
              if (this._mouseDownType == exports.MouseDownType.RIGHT) {
                  this.translate(ev);
                  return;
              }
              if (this._mouseDownType == exports.MouseDownType.LEFT &&
                  this.currentEventType == exports.EditorEventType.NodeActive &&
                  this._mouseDownPosition[0] != 0) {
                  this.NodeMoveHandler(ev);
                  return;
              }
              if (this.currentEventType === exports.EditorEventType.LineBegin) {
                  const [ox, oy] = this.getScaleOffset(ev.clientX - this._translateLast[0], ev.clientY - this._translateLast[1]);
                  this.currentLine.update(this.currentLine._begin, new Point(ox, oy));
                  return;
              }
              if (this._mouseDownType === exports.MouseDownType.LEFT &&
                  this.currentEventType === exports.EditorEventType.Normal) {
                  const ow = ev.clientX - this._mouseDownPosition[0];
                  const oh = ev.clientY - this._mouseDownPosition[1];
                  if (this.selector.isHidden === true) {
                      this.selector.show();
                  }
                  this.selector.update(this._mouseDownPosition[0], this._mouseDownPosition[1], ow, oh);
                  this.SelectHandler(this.selector.x, this.selector.y, this.selector.width, this.selector.height);
              }
          });
          this.container.addEventListener('mousewheel', (ev) => {
              this.ScaleHandler(ev);
          });
          this.selector = new Selector();
      }
      add(node) {
          this.container.appendChild(node.instance);
          this.graph.push(node);
      }
      addLine(line) {
          this.lineContainer.appendChild(line.instance);
      }
      translate(ev) {
          const goalX = ev.clientX - this._mouseDownPosition[0] + this._transform.translate[0];
          const goalY = ev.clientY - this._mouseDownPosition[1] + this._transform.translate[1];
          this.container.style.transform = `translate(${goalX}px, ${goalY}px) scale(${this.scale})`;
          this._translateLast = [goalX, goalY];
      }
      setMouseDownType(type) {
          if (type === 2) {
              this._mouseDownType = 2;
          }
          else if (type === 0) {
              this._mouseDownType = 0;
          }
      }
      recordPosition(x, y) {
          this._mouseDownPosition[0] = x;
          this._mouseDownPosition[1] = y;
      }
      initLineContainer() {
          const svg = createSvg('svg');
          svg.style.width = this.container.getClientRects()[0].width + 'px';
          svg.style.height = this.container.getClientRects()[0].height + 'px';
          svg.style.left = 0;
          svg.style.top = 0;
          this.lineContainer = svg;
          this.container.appendChild(this.lineContainer);
      }
      PreNodeHandler() { }
      ScaleHandler(ev) {
          if (ev.deltaY < 0) {
              if (this.scale >= 1)
                  return;
              this.scale += 0.1;
              this.container.style.transformOrigin = `${ev.x}px ${ev.y}px`;
              this._transform.transformOrigin = `${ev.x}px ${ev.y}px`;
              this.container.style.transform = `translate(${this._transform.translate[0]}px, ${this._transform.translate[1]}px) scale(${this.scale})`;
          }
          else {
              if (this.scale <= 0.7)
                  return;
              this.scale -= 0.1;
              this.container.style.transformOrigin = `${ev.x}px ${ev.y}px`;
              this._transform.transformOrigin = `${ev.x}px ${ev.y}px`;
              this.container.style.transform = `translate(${this._transform.translate[0]}px, ${this._transform.translate[1]}px) scale(${this.scale})`;
          }
      }
      NodeMoveHandler(ev) {
          this.currentTarget.position = {
              x: ev.clientX - this._mouseDownPosition[0] + this._mouseDownPosition[2],
              y: ev.clientY - this._mouseDownPosition[1] + this._mouseDownPosition[3],
          };
      }
      NodeActiveHandler(node) {
          this.currentEventType = exports.EditorEventType.NodeActive;
          this.currentTarget = node;
          this._mouseDownPosition[0] = 0;
          this._mouseDownPosition[1] = 0;
          this._mouseDownPosition[2] = node.x;
          this._mouseDownPosition[3] = node.y;
      }
      getScaleOffset(x, y) {
          const originOffset = this._transform.transformOrigin
              .replace(/px/g, '')
              .split(' ');
          const xc = +originOffset[0];
          const yc = +originOffset[1];
          const m1 = [1, 0, 0, 0, 1, 0, xc, yc, 1];
          const m2 = [1 / this.scale, 0, 0, 0, 1 / this.scale, 0, 0, 0, 1];
          const m3 = [1, 0, 0, 0, 1, 0, -xc, -yc, 1];
          let m4 = [0, 0, 0, 0, 0, 0, 0, 0, 0];
          let m5 = [0, 0, 0, 0, 0, 0, 0, 0, 0];
          multiply(m4, m1, m2);
          multiply(m5, m4, m3);
          const r = [0, 0];
          transformMat3(r, [x, y], m5);
          return [...r];
      }
      getScaleOffset_T(x, y) {
          const originOffset = this._transform.transformOrigin
              .replace(/px/g, '')
              .split(' ');
          const xc = +originOffset[0];
          const yc = +originOffset[1];
          const m1 = [1, 0, 0, 0, 1, 0, xc, yc, 1];
          const m2 = [1 * this.scale, 0, 0, 0, 1 * this.scale, 0, 0, 0, 1];
          const m3 = [1, 0, 0, 0, 1, 0, -xc, -yc, 1];
          let m4 = [0, 0, 0, 0, 0, 0, 0, 0, 0];
          let m5 = [0, 0, 0, 0, 0, 0, 0, 0, 0];
          multiply(m4, m1, m2);
          multiply(m5, m4, m3);
          const r = [0, 0];
          transformMat3(r, [x, y], m5);
          return [...r];
      }
      isLineBegin() {
          return this.currentEventType === exports.EditorEventType.LineBegin;
      }
      handleConnectPointClick(info) {
          this.currentTarget = info.node;
          if (!this.isLineBegin()) {
              this.currentEventType = exports.EditorEventType.LineBegin;
              this.beginNode = info.node;
              this.beginType = exports.BeginType.NODE;
              const t = new Line(new Point(info.pos[0], info.pos[1]), new Point(info.pos[0], info.pos[1]));
              t.beginNodeConnectType = info.isPre
                  ? NodeConnectType.PRE
                  : NodeConnectType.NEXT;
              this.currentLine = t;
              this.addLine(t);
          }
          else {
              if (this.beginType === exports.BeginType.PROCESS) {
                  this.currentEventType = exports.EditorEventType.LineEnd;
                  this.currentLine.update(this.currentLine._begin, new Point(info.pos[0], info.pos[1]));
                  this.currentLine.beginNode = this.beginNode;
                  this.lineGraph.push(this.currentLine);
                  this.beginParam.connect(this.currentLine, info.node, 'begin');
                  info.line = this.currentLine;
                  info.node.connect(info, exports.ConnectPosition.END);
                  this.resetAfterAttachLine();
                  return;
              }
              if (this.beginType !== exports.BeginType.NODE)
                  return;
              const endPointConnectType = info.isPre
                  ? NodeConnectType.PRE
                  : NodeConnectType.NEXT;
              if (this.currentLine.beginNodeConnectType === endPointConnectType)
                  return;
              this.currentEventType = exports.EditorEventType.LineEnd;
              this.currentLine.endNodeConnectType = endPointConnectType;
              this.currentLine.update(this.currentLine._begin, new Point(info.pos[0], info.pos[1]));
              this.lineGraph.push(this.currentLine);
              info.node = this.beginNode;
              info.line = this.currentLine;
              this.currentTarget.connect(info, exports.ConnectPosition.END);
              info.isPre = !info.isPre;
              info.node = this.currentTarget;
              this.beginNode.connect(info, exports.ConnectPosition.BEGIN);
              this.resetAfterAttachLine();
          }
      }
      paramPointClickHandler(info) {
          this.currentTarget = info.node;
          if (this.currentEventType !== exports.EditorEventType.LineBegin) {
              this.currentEventType = exports.EditorEventType.LineBegin;
              this.beginParam = info.param;
              this.beginNode = info.node;
              this.beginType = exports.BeginType.PARAM;
              const t = new Line(new Point(info.pos[0], info.pos[1]), new Point(info.pos[0], info.pos[1]), { color: info.param.point.color });
              t.beginNodeConnectType = info.param.isInput
                  ? NodeConnectType.PRE
                  : NodeConnectType.NEXT;
              this.currentLine = t;
              this.addLine(t);
          }
          else {
              if (this.beginType !== exports.BeginType.PARAM)
                  return;
              if (info.param.type !== this.beginParam.type) {
                  return;
              }
              if (info.param.isConnected)
                  return;
              this.currentEventType = exports.EditorEventType.LineEnd;
              this.currentLine.update(this.currentLine._begin, new Point(info.pos[0], info.pos[1]));
              this.lineGraph.push(this.currentLine);
              this.beginParam.connect(this.currentLine, info.param, 'begin');
              info.param.connect(this.currentLine, this.beginParam, 'end');
              this.resetAfterAttachLine();
          }
      }
      processPointClickHandler(info) {
          this.currentTarget = info.node;
          if (this.currentEventType !== exports.EditorEventType.LineBegin) {
              this.currentEventType = exports.EditorEventType.LineBegin;
              this.beginParam = info.param;
              this.beginNode = info.node;
              this.beginType = exports.BeginType.PROCESS;
              const t = new Line(new Point(info.pos[0], info.pos[1]), new Point(info.pos[0], info.pos[1]), { color: 'white' });
              t.beginNodeConnectType = NodeConnectType.NEXT;
              this.currentLine = t;
              this.addLine(t);
          }
          else {
              if (info.param.isConnected)
                  return;
              this.currentEventType = exports.EditorEventType.LineEnd;
              this.currentLine.update(this.currentLine._begin, new Point(info.pos[0], info.pos[1]));
              this.currentLine.endNode = info.param.parent;
              this.lineGraph.push(this.currentLine);
              info.line = this.currentLine;
              info.isPre = true;
              this.beginNode.connect(info, exports.ConnectPosition.BEGIN);
              info.param.connect(this.currentLine, this.beginNode, 'end');
              this.resetAfterAttachLine();
          }
      }
      resetAfterAttachLine() {
          this.beginNode = null;
          this.beginParam = null;
          this.beginType = null;
          this.currentLine = null;
          this.currentEventType = exports.EditorEventType.Normal;
      }
      SelectHandler(x, y, width, height) {
          this.graph.forEach((item, index) => {
              const [tx, ty] = this.getScaleOffset_T(item.x, item.y);
              const isT = intersection_rectangle(x, y, width, height, tx + this._translateLast[0], ty + this._translateLast[1], item.width * this.scale, item.height * this.scale);
              if (isT) {
                  item.selected = true;
              }
              else {
                  item.selected = false;
              }
          });
      }
  }

  class Label {
      constructor(options) {
          this._text = '';
          this.instance = createSpan();
          this.instance.setAttribute('class', 'wb-param-label');
          if (options.text) {
              this.text = options.text;
          }
          else {
              this.text = '未命名';
          }
      }
      get text() {
          return this._text;
      }
      set text(value) {
          this._text = value;
          this.instance.innerText = value;
      }
  }

  const getColor = (type) => {
      let color;
      switch (type) {
          case 'string':
              color = '#f703cf';
              break;
          case 'boolean':
              color = '#8e020b';
              break;
          case 'object':
              color = '#20a5e8';
              break;
          case 'number':
              color = '#a4fa60';
              break;
          case 'process':
              color = 'white';
              break;
          case 'any':
              color = '#eeeeee';
              break;
      }
      return color;
  };
  class ParamPoint {
      constructor(options) {
          this.uid = uuid();
          this.type = options.type;
          this.init();
      }
      init() {
          const svg = createSvg('svg');
          svg.setAttribute('class', 'wb-inputPoint-' + this.type);
          const color = getColor(this.type);
          this.color = color;
          if (this.type === 'process') {
              const polygon = createSvg('polygon');
              polygon.setAttribute('points', '0,0 10,5 0,10');
              polygon.setAttribute('stroke-width', '1px');
              polygon.setAttribute('stroke', 'white');
              polygon.setAttribute('fill', 'none');
              this.inside = polygon;
              svg.appendChild(polygon);
          }
          else {
              const circle = createSvg('circle');
              circle.setAttribute('cx', '5');
              circle.setAttribute('cy', '5');
              circle.setAttribute('r', '4');
              circle.setAttribute('stroke-width', '1px');
              circle.setAttribute('fill', 'none');
              circle.setAttribute('stroke', color);
              this.inside = circle;
              svg.appendChild(circle);
          }
          this.instance = svg;
      }
      update() { }
      connect() {
          this.inside.setAttribute('fill', this.color);
      }
      disConnect() {
          this.inside.setAttribute('fill', 'none');
      }
  }

  class Input {
      constructor(options) {
          this.type = options.type;
          this.create();
      }
      create() {
          const box = createDiv();
          box.setAttribute('class', 'wb-input-box');
          let inputBox;
          switch (this.type) {
              case 'number':
                  inputBox = createInputNumberBox();
                  inputBox.setAttribute('class', 'wb-input-number');
                  break;
              case 'string':
                  inputBox = createInputTextBox();
                  inputBox.setAttribute('class', 'wb-input-string');
                  break;
              case 'boolean':
                  inputBox = createCheckBox();
                  inputBox.setAttribute('class', 'wb-input-checkbox');
                  break;
              default:
                  inputBox = createDiv();
          }
          inputBox.oninput = this.inputChangeHanlde.bind(this);
          box.appendChild(inputBox);
          this.inputIntance = inputBox;
          this.instance = box;
      }
      inputChangeHanlde(v) {
          this.value = this.inputIntance.value;
          this.parent.update(this.value);
      }
      get value() {
          return this._value;
      }
      set value(s) {
          this._value = s;
      }
      hidden() {
          this.instance.style.display = 'none';
      }
      show() {
          this.instance.style.display = '';
      }
  }

  class Param {
      constructor(options) {
          this.classType = ClassType.PARAM;
          this.uid = uuid();
          this.type = '';
          this.name = '';
          this._value = '';
          this.isConnected = false;
          this.linkedObjects = [];
          this.type = options.type;
          this.isInput = options.isInput !== undefined ? options.isInput : true;
          this.name = options.name !== undefined ? options.name : 'unknown';
          this.value = options.value !== undefined ? options.value : '';
          this.create();
      }
      get value() {
          if (this.isConnected && this.isInput) {
              return this.linkedParam.value;
          }
          return this._value;
      }
      set value(value) {
          this._value = value;
      }
      create() {
          this.instance = createDiv();
          this.instance.setAttribute('class', 'wb-param-base');
          this.point = new ParamPoint({ type: this.type });
          this.label = new Label({ text: this.name });
          this.input = new Input({ type: this.type });
          this.input.parent = this;
          if (this.isInput) {
              this.add(this.point);
              this.add(this.label);
              this.add(this.input);
          }
          else {
              this.add(this.label);
              this.add(this.point);
          }
      }
      add(ele) {
          this.instance.appendChild(ele.instance);
      }
      connect(line, wpElement, position) {
          if (wpElement.classType === ClassType.NODE) {
              const node = wpElement;
              this.point.connect();
              this.isConnected = true;
              this.linkedObjects.push({
                  line,
                  node,
                  id: node.nodeId,
                  classType: ClassType.NODE,
              });
              if (position === 'begin') {
                  this.isBeign = true;
              }
              else {
                  this.isBeign = false;
              }
          }
          if (wpElement.classType === ClassType.PARAM) {
              const param = wpElement;
              if (this.isInput && this.isConnected)
                  return;
              this.point.connect();
              this.isConnected = true;
              this.input.hidden();
              if (!this.isInput) {
                  this.linkedObjects.push({
                      line,
                      param,
                      id: param.uid,
                      classType: ClassType.PARAM,
                  });
              }
              else {
                  this.linkedLine = line;
                  this.linkedParam = param;
              }
              if (position === 'begin') {
                  this.isBeign = true;
              }
              else {
                  this.isBeign = false;
              }
              if (this.isInput) {
                  this.update(param.value);
              }
          }
      }
      disConnect(paramId) {
          if (this.isInput) {
              this.value = '';
              this.isConnected = false;
              this.input.show();
              this.point.disConnect();
              this.linkedLine.destory();
              this.linkedParam.disConnect(this.uid);
              this.linkedParam = null;
              this.linkedLine = null;
          }
          else {
              const index = this.linkedObjects.findIndex((item) => item.param.uid === paramId);
              if (index === -1)
                  return;
              this.linkedObjects[index].line.destory();
              this.linkedObjects.splice(index, 1);
              if (this.linkedObjects.length === 0) {
                  this.isConnected = false;
                  this.point.disConnect();
              }
          }
      }
      update(value) {
          this.value = value;
      }
  }

  exports.ConnectPosition = void 0;
  (function (ConnectPosition) {
      ConnectPosition["BEGIN"] = "begin";
      ConnectPosition["END"] = "END";
  })(exports.ConnectPosition || (exports.ConnectPosition = {}));
  class Node extends BaseNode {
      constructor(params) {
          super();
          this.headerClass = 'wb-container-base-header';
          this.active = false;
          this._selected = false;
          this.nodeName = params.nodeName;
          if (params.headerClass) {
              this.headerClass = params.headerClass;
          }
          if (params.color) {
              this.color = params.color;
          }
          this.func = params.func;
          this.initContainer();
          this.initHeader();
          this.instance.appendChild(this.header);
          this.initBody();
          this.instance.appendChild(this.body);
          if (params.preNodeRequired || params.preNodeRequired === undefined) {
              this.preNodeRequired = true;
          }
          else {
              this.preNodeRequired = false;
          }
          if (params.nextNodeRequired || params.nextNodeRequired === undefined) {
              this.nextNodeRequired = true;
          }
          else {
              this.nextNodeRequired = false;
          }
          if (this.nextNodeRequired || this.preNodeRequired) {
              this.initPrePoint(this.preNodeRequired);
              this.leftBody.appendChild(this.prePoint);
              this.initNextPoint(this.nextNodeRequired);
              this.rightBody.appendChild(this.nextPoint);
          }
          if (!this.nextNodeRequired && !this.preNodeRequired) {
              this.yAxisPak = 0;
          }
          if (params.input && params.input.length > 0) {
              params.input.forEach((item, index) => {
                  this.addInput(this.initInput(item, index));
              });
          }
          if (params.output && params.output.length > 0) {
              params.output.forEach((item, index) => {
                  this.addOutput(this.initOutput(item, index));
              });
          }
          this.x = params.x || 0;
          this.y = params.y || 0;
          if (params.nodeLabel) {
              this.initLabel(params.nodeLabel);
          }
      }
      get x() {
          return this._x;
      }
      set x(value) {
          this._x = value;
          this.instance.style.left = `${this._x}px`;
      }
      get y() {
          return this._y;
      }
      set y(value) {
          this._y = value;
          this.instance.style.top = `${this._y}px`;
      }
      get position() {
          return {
              x: this._x,
              y: this._y,
          };
      }
      get width() {
          return this.instance.clientWidth;
      }
      get height() {
          return this.instance.clientHeight;
      }
      get selected() {
          return this._selected;
      }
      set selected(value) {
          if (this._selected === value) {
              return;
          }
          this._selected = value;
          if (value) {
              this.instance.className = this.instance.className + ' ' + 'selected';
          }
          else {
              this.instance.className = this.instance.className.replace(' selected', '');
          }
      }
      set position(pos) {
          this.x = pos.x;
          this.y = pos.y;
          this.updateRelativeLines(pos.x, pos.y);
      }
      get nodeLabel() {
          return this._nodeLabel;
      }
      set nodeLabel(label) {
          this._nodeLabel = label;
      }
      initContainer() {
          const div = createDiv();
          div.className = 'wb-container-base';
          this.instance = div;
          this.instance.addEventListener('mousedown', () => {
              IO.emit('NodeActive', this);
          });
          this.instance.addEventListener('mouseup', () => {
              IO.emit('NodeInactive', this);
          });
      }
      initHeader() {
          const div = createDiv();
          div.className = this.headerClass;
          div.innerText = this.nodeName;
          if (this.color) {
              div.style.background = this.color;
          }
          this.header = div;
      }
      initBody() {
          const div = createDiv();
          div.className = 'wb-container-base-body';
          const left = createDiv();
          left.className = 'wb-container-base-body-left';
          const right = createDiv();
          right.className = 'wb-container-base-body-right';
          div.appendChild(left);
          div.appendChild(right);
          this.leftBody = left;
          this.rightBody = right;
          this.body = div;
      }
      initPrePoint(ifNeed) {
          const svg = createSvg('svg');
          svg.setAttribute('class', 'wb-prePoint');
          if (!ifNeed) {
              this.prePoint = svg;
              return;
          }
          const polygon = createSvg('polygon');
          polygon.setAttribute('points', '0,0 0,10 5,10 9,5 5,0');
          polygon.setAttribute('stroke-width', '2px');
          polygon.setAttribute('stroke', 'white');
          polygon.setAttribute('fill', 'none');
          svg.appendChild(polygon);
          svg.addEventListener('mousedown', (ev) => {
              ev.cancelBubble = true;
          });
          svg.addEventListener('mouseup', (ev) => {
              ev.cancelBubble = true;
          });
          svg.addEventListener('click', (ev) => {
              ev.cancelBubble = true;
              const info = {
                  pos: this.getPrePointPosition(),
                  node: this,
                  isPre: true,
              };
              if (ev.button === 0) {
                  IO.emit('ConnectPointClick', info);
                  return;
              }
              if (ev.button === 2) {
                  IO.emit('ConnectPointRightClick', info);
              }
          });
          svg.addEventListener('mouseenter', () => {
              IO.emit('ConnectPointEnter', {
                  node: this,
                  isPre: true,
              });
          });
          svg.addEventListener('mouseleave', () => {
              IO.emit('ConnectPointLeave', {
                  node: this,
                  isPre: true,
              });
          });
          this.prePoint = svg;
      }
      initNextPoint(ifNeed) {
          const svg = createSvg('svg');
          svg.setAttribute('class', 'wb-nextPoint');
          if (!ifNeed) {
              this.nextPoint = svg;
              return;
          }
          const polygon = createSvg('polygon');
          polygon.setAttribute('points', '0,0 0,10 5,10 9,5 5,0');
          polygon.setAttribute('stroke-width', '2px');
          polygon.setAttribute('stroke', 'white');
          polygon.setAttribute('fill', 'none');
          svg.appendChild(polygon);
          svg.addEventListener('mousedown', (ev) => {
              ev.cancelBubble = true;
          });
          svg.addEventListener('mouseup', (ev) => {
              ev.cancelBubble = true;
          });
          svg.addEventListener('click', (ev) => {
              ev.cancelBubble = true;
              IO.emit('ConnectPointClick', {
                  pos: this.getNextPointPosition(),
                  node: this,
                  isPre: false,
              });
          });
          this.nextPoint = svg;
      }
      initInput({ type, value, name }, index) {
          const box = new Param({ type, value, name });
          box.instance.addEventListener('mousedown', (ev) => {
              ev.cancelBubble = true;
          });
          box.instance.addEventListener('mouseup', (ev) => {
              ev.cancelBubble = true;
          });
          box.point.instance.addEventListener('click', (ev) => {
              IO.emit('ParamPointClick', {
                  pos: this.getParamPosition(index),
                  node: this,
                  param: box,
              });
          });
          return box;
      }
      addInput(param) {
          this.inputPoints.push(param);
          param.parent = this;
          this.leftBody.appendChild(param.instance);
      }
      initOutput({ type, value, name }, index) {
          const box = new Param({ type, value, name, isInput: false });
          box.instance.addEventListener('mousedown', (ev) => {
              ev.cancelBubble = true;
          });
          box.instance.addEventListener('mouseup', (ev) => {
              ev.cancelBubble = true;
          });
          box.point.instance.addEventListener('click', (ev) => {
              if (box.type !== 'process') {
                  IO.emit('ParamPointClick', {
                      pos: this.getParamPosition(index, false),
                      node: this,
                      param: box,
                  });
              }
              else {
                  IO.emit('ProcessPointClick', {
                      pos: this.getParamPosition(index, false),
                      node: this,
                      param: box,
                  });
              }
          });
          return box;
      }
      addOutput(param) {
          this.outPutPoints.push(param);
          param.parent = this;
          this.rightBody.appendChild(param.instance);
      }
      initLabel(labelText) {
          const label = createSpan();
          label.setAttribute('class', 'wb-container-base-header-label');
          label.innerText = labelText;
          this.header.append(label);
      }
      connect(info, position) {
          if (info.isPre) {
              this.preNodes.push(info.node);
              const inside = this.prePoint.childNodes[0];
              inside.setAttribute('fill', 'white');
              this.preLines.push(info.line);
          }
          else {
              this.nextNodes.push(info.node);
              const inside = this.nextPoint.childNodes[0];
              inside.setAttribute('fill', 'white');
              this.nextLines.push(info.line);
          }
          if (position === exports.ConnectPosition.BEGIN) {
              info.line.beginNode = this;
          }
          else {
              info.line.endNode = this;
          }
      }
      updateRelativeLines(x, y) {
          this.preLines.forEach((line) => {
              var _a;
              const [ix, iy] = this.getPrePointPosition();
              if (((_a = line.beginNode) === null || _a === void 0 ? void 0 : _a.nodeId) === this.nodeId) {
                  line.update(new Point(ix, iy), line._end);
              }
              else {
                  line.update(line._begin, new Point(ix, iy));
              }
          });
          this.nextLines.forEach((line) => {
              var _a;
              const [ix, iy] = this.getNextPointPosition();
              if (((_a = line.beginNode) === null || _a === void 0 ? void 0 : _a.nodeId) === this.nodeId) {
                  line.update(new Point(ix, iy), line._end);
              }
              else {
                  line.update(line._begin, new Point(ix, iy));
              }
          });
          this.inputPoints.forEach((param, index) => {
              if (!param.linkedLine)
                  return;
              const [ix, iy] = this.getParamPosition(index, true);
              if (param.isBeign) {
                  param.linkedLine.update(new Point(ix, iy), param.linkedLine._end);
              }
              else {
                  param.linkedLine.update(param.linkedLine._begin, new Point(ix, iy));
              }
          });
          this.outPutPoints.forEach((param, index) => {
              if (!param.linkedObjects)
                  return;
              const [ix, iy] = this.getParamPosition(index, false);
              if (param.isBeign) {
                  param.linkedObjects.forEach((item) => {
                      item.line.update(new Point(ix, iy), item.line._end);
                  });
              }
              else {
                  param.linkedObjects.forEach((item) => {
                      item.line.update(item.line._begin, new Point(ix, iy));
                  });
              }
          });
      }
      disConnect(id, isPre) {
          let relativeNode;
          if (isPre) {
              const index = this.preNodes.findIndex((item) => item.nodeId === id);
              if (index === -1)
                  return;
              relativeNode = this.preNodes[index];
              this.preNodes.splice(index, 1);
              const lineIndex = this.preLines.findIndex((item) => {
                  return item.beginNode.nodeId === id || item.endNode.nodeId === id;
              });
              if (lineIndex === -1)
                  return;
              IO.emit('LineRemove', this.preLines[lineIndex].id);
              this.preLines.splice(lineIndex, 1);
          }
          else {
              const index = this.nextNodes.findIndex((item) => item.nodeId === id);
              if (index === -1)
                  return;
              relativeNode = this.nextNodes[index];
              this.nextNodes.splice(index, 1);
              const lineIndex = this.nextLines.findIndex((item) => {
                  return item.beginNode.nodeId === id || item.endNode.nodeId === id;
              });
              if (lineIndex === -1)
                  return;
              IO.emit('LineRemove', this.nextLines[lineIndex].id);
              this.nextLines.splice(lineIndex, 1);
          }
          this.callRelativeNodeDisconnect(relativeNode, !isPre);
          this.updatePreOrNextConnectedStatus();
      }
      callRelativeNodeDisconnect(node, isPre) {
          node.disConnect(this.nodeId, isPre);
          node.updatePreOrNextConnectedStatus();
      }
      updatePreOrNextConnectedStatus() {
          const child1 = this.prePoint.childNodes[0];
          const child2 = this.nextPoint.childNodes[0];
          if (this.preLines.length === 0) {
              child1.setAttribute('fill', 'none');
          }
          else {
              child1.setAttribute('fill', 'white');
          }
          if (this.nextLines.length === 0) {
              child2.setAttribute('fill', 'none');
          }
          else {
              child2.setAttribute('fill', 'white');
          }
      }
  }

  class Line extends BaseLine {
      constructor(begin, end, options = {}) {
          super();
          if (options.color)
              this._color = options.color;
          const Path = createSvg('path');
          this.instance = Path;
          Path.setAttribute('stroke-width', '2px');
          Path.setAttribute('stroke', this.color);
          Path.setAttribute('fill', 'none');
          this.update(begin, end);
      }
      get color() {
          return this._color;
      }
      set color(value) {
          this._color = value;
          this.instance.setAttribute('stroke', value);
      }
      update(begin, end) {
          let cp;
          let path;
          if (this.beginNodeConnectType === NodeConnectType.NEXT) {
              cp = this._getControlPoint(begin, end);
              path = `M${begin.x},${begin.y} C${cp[0]},${cp[1]} ${cp[2]},${cp[3]} ${end.x},${end.y}`;
          }
          else {
              cp = this._getControlPoint(end, begin);
              path = `M${end.x},${end.y} C${cp[0]},${cp[1]} ${cp[2]},${cp[3]} ${begin.x},${begin.y}`;
          }
          this._begin = begin;
          this._end = end;
          this._setSize();
          this.instance.setAttribute('d', path);
      }
      destory() {
          try {
              this.instance.parentNode.removeChild(this.instance);
          }
          catch (error) { }
      }
  }

  exports.BaseNode = BaseNode;
  exports.BluePrintEditor = BluePrintEditor;
  exports.Line = Line;
  exports.Node = Node;
  exports.Point = Point;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({});
