var blueprint = (function (exports) {
  'use strict';

  const map = '123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
  function uuid() {
      let ranStr = '';
      for (let i = 0; i < 19; i++) {
          ranStr += map[Math.floor(Math.random() * (48 + 9))];
      }
      return ranStr + new Date().getTime();
  }

  class BaseNode {
      constructor() {
          this.inputPoints = [];
          this.outPutPoints = [];
          this.variables = {};
          this.nodeName = 'Function Name';
          this.nodeType = 'Function';
          this.nodeId = uuid();
          this.async = false;
          this._x = 0;
          this._y = 0;
          this.preNodes = [];
          this.nextNodes = [];
          this.preLines = [];
          this.nextLines = [];
      }
      execute() {
          this.func(this.inputPoints);
          this.nextNodes.forEach((item) => {
              item.execute();
          });
      }
      getPrePointPosition() {
          return [this._x + 10, this._y + 32 + 10 + 5];
      }
      getNextPointPosition() {
          return [this._x + 200 - 10, this._y + 32 + 10 + 5];
      }
  }

  class Point {
      constructor(x, y) {
          this.x = x;
          this.y = y;
      }
      middileWith(p) {
          const mx = (this.x + p.x) / 2;
          const my = (this.y + p.y) / 2;
          return new Point(mx, my);
      }
      distanceWith(p) {
          return Math.pow((p.x - this.x) * (p.x - this.x) + (p.y - this.y) * (p.y - this.y), 0.5);
      }
  }

  class IO {
      constructor() { }
      static on(eventName, listener, options = {}) {
          if (eventName === undefined || listener === undefined) {
              console.error('event or listener is required!');
              return;
          }
          if (!(eventName in this._events)) {
              this._events[eventName] = [];
          }
          if (this._events[eventName].length >= this.MAX_LISTENERS) {
              console.error(`${eventName}'s number of listeners has reached the limit`);
              return;
          }
          if (options.only) {
              if (this._events[eventName].length !== 0) {
                  return;
              }
          }
          this._events[eventName].push({
              handler: listener,
              once: options.once != undefined ? options.once : false,
          });
      }
      static emit(eventName, ...args) {
          if (!(eventName in this._events)) {
              return false;
          }
          const listeners = this._events[eventName];
          try {
              listeners.forEach((eventTarget) => {
                  eventTarget.handler(...args);
                  if (eventTarget.once) {
                      this.removeListener(eventName, eventTarget.handler);
                  }
              });
          }
          catch (error) {
              console.error(error);
          }
      }
      static once(eventName, listener) {
          this.on(eventName, listener, { once: true });
      }
      static off(eventName, listener) {
          this.removeListener(eventName, listener);
      }
      static removeListener(eventName, listener) {
          if (!(eventName in this._events)) {
              console.warn(`there is no event named ${eventName}`);
              return false;
          }
          let listenerIndex = null;
          for (let i = 0, l = this._events[eventName].length; i < l; i++) {
              if (this._events[eventName][i].handler === listener) {
                  listenerIndex = i;
                  break;
              }
          }
          if (listenerIndex !== null) {
              this._events[eventName].splice(listenerIndex, 1);
          }
      }
      static removeAllListener(eventName) {
          if (this._events[eventName] === undefined) {
              console.warn(`there is no event named ${eventName}`);
              return false;
          }
          this._events[eventName] = [];
      }
      static setMaxListeners(num) {
          this.MAX_LISTENERS = num;
      }
      static clear() {
          this._events = Object.create(null);
      }
  }
  IO._events = Object.create(null);
  IO.MAX_LISTENERS = 30;

  const createDom = (tag) => {
      return document.createElement(tag);
  };
  const createDiv = () => {
      return createDom('div');
  };
  const createSvg = (tag) => {
      return document.createElementNS('http://www.w3.org/2000/svg', tag);
  };
  const createSpan = () => {
      return createDom('span');
  };

  /**
   * Common utilities
   * @module glMatrix
   */
  var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
  if (!Math.hypot) Math.hypot = function () {
    var y = 0,
        i = arguments.length;

    while (i--) {
      y += arguments[i] * arguments[i];
    }

    return Math.sqrt(y);
  };

  /**
   * Multiplies two mat3's
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the first operand
   * @param {ReadonlyMat3} b the second operand
   * @returns {mat3} out
   */

  function multiply(out, a, b) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    var b00 = b[0],
        b01 = b[1],
        b02 = b[2];
    var b10 = b[3],
        b11 = b[4],
        b12 = b[5];
    var b20 = b[6],
        b21 = b[7],
        b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }

  /**
   * 2 Dimensional Vector
   * @module vec2
   */

  /**
   * Creates a new, empty vec2
   *
   * @returns {vec2} a new 2D vector
   */

  function create() {
    var out = new ARRAY_TYPE(2);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }

    return out;
  }
  /**
   * Transforms the vec2 with a mat3
   * 3rd vector component is implicitly '1'
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the vector to transform
   * @param {ReadonlyMat3} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat3(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
  }
  /**
   * Perform some operation over an array of vec2s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  (function () {
    var vec = create();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 2;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
      }

      return a;
    };
  })();

  exports.MouseDownType = void 0;
  (function (MouseDownType) {
      MouseDownType[MouseDownType["LEFT"] = 0] = "LEFT";
      MouseDownType[MouseDownType["RIGHT"] = 2] = "RIGHT";
      MouseDownType[MouseDownType["NONE"] = -1] = "NONE";
  })(exports.MouseDownType || (exports.MouseDownType = {}));
  exports.EditorEventType = void 0;
  (function (EditorEventType) {
      EditorEventType["Normal"] = "normal";
      EditorEventType["NodeActive"] = "NodeActive";
      EditorEventType["LineBegin"] = "LineBegin";
      EditorEventType["LineEnd"] = "LineEnd";
  })(exports.EditorEventType || (exports.EditorEventType = {}));
  class BluePrintEditor {
      constructor(container) {
          this.graph = [];
          this.lineGraph = [];
          this.scale = 1;
          this._orginSize = [];
          this._mouseDownType = -1;
          this._mouseDownPosition = [];
          this._translateLast = [0, 0];
          this._transform = {
              translate: [0, 0],
              transformOrigin: '0px 0px',
          };
          this.currentEventType = exports.EditorEventType.Normal;
          IO.emit('beforeCreated');
          IO.on('NodeActive', (node) => {
              if (this.currentEventType === exports.EditorEventType.LineBegin)
                  return;
              this.NodeActiveHandler(node);
          }, { only: true });
          IO.on('NodeInactive', () => {
              if (this.currentEventType !== exports.EditorEventType.LineBegin) {
                  this.currentEventType = exports.EditorEventType.Normal;
              }
              this.currentTarget = null;
          }, { only: true });
          IO.on('ConnectPointClick', (info) => {
              console.log(info);
              this.currentTarget = info.node;
              if (this.currentEventType !== exports.EditorEventType.LineBegin) {
                  this.currentEventType = exports.EditorEventType.LineBegin;
                  this.beginNode = info.node;
                  const t = new Line(new Point(info.pos[0], info.pos[1]), new Point(info.pos[0], info.pos[1]));
                  this.currentLine = t;
                  this.addLine(t);
              }
              else {
                  this.currentEventType = exports.EditorEventType.LineEnd;
                  this.currentLine.update(this.currentLine._begin, new Point(info.pos[0], info.pos[1]));
                  this.lineGraph.push(this.currentLine);
                  info.node = this.beginNode;
                  info.line = this.currentLine;
                  this.currentTarget.connect(info);
                  info.isPre = !info.isPre;
                  info.node = this.currentTarget;
                  info.node = this.beginNode.connect(info);
                  this.beginNode = null;
                  this.currentLine = null;
                  this.currentEventType = exports.EditorEventType.Normal;
              }
          }, { only: true });
          IO.on('ConnectPointEnter', (info) => { }, { only: true });
          container.oncontextmenu = function () {
              return false;
          };
          this.container = container;
          this._orginSize[0] = this.container.getClientRects()[0].width;
          this._orginSize[1] = this.container.getClientRects()[0].height;
          container.style.position = 'relative';
          container.style.transform = 'scale(1)';
          this.initLineContainer();
          this.init();
      }
      init() {
          this.container.addEventListener('mousedown', (ev) => {
              this.setMouseDownType(ev.button);
              this.recordPosition(ev.clientX, ev.clientY);
          });
          this.container.addEventListener('mouseup', (ev) => {
              this._mouseDownType = -1;
              this._transform.translate = [...this._translateLast];
              this._mouseDownPosition = [];
              if (this.currentEventType === exports.EditorEventType.LineBegin) {
                  this.currentLine.destory();
                  this.currentLine = null;
                  this.currentEventType = exports.EditorEventType.Normal;
              }
          });
          this.container.addEventListener('mousemove', (ev) => {
              if (this._mouseDownType == exports.MouseDownType.RIGHT) {
                  this.translate(ev);
                  return;
              }
              if (this._mouseDownType == exports.MouseDownType.LEFT &&
                  this.currentEventType == exports.EditorEventType.NodeActive &&
                  this._mouseDownPosition[0] != 0) {
                  this.NodeMoveHandler(ev);
              }
              if (this.currentEventType === exports.EditorEventType.LineBegin) {
                  const [ox, oy] = this.getScaleOffset(ev.clientX - this._translateLast[0], ev.clientY - this._translateLast[1]);
                  this.currentLine.update(this.currentLine._begin, new Point(ox, oy));
              }
          });
          this.container.addEventListener('mousewheel', (ev) => {
              this.ScaleHandler(ev);
              this.resize(this.scale);
          });
      }
      add(node) {
          this.container.appendChild(node.instance);
          this.graph.push(node);
      }
      addLine(line) {
          this.lineContainer.appendChild(line.instance);
      }
      translate(ev) {
          const goalX = ev.clientX - this._mouseDownPosition[0] + this._transform.translate[0];
          const goalY = ev.clientY - this._mouseDownPosition[1] + this._transform.translate[1];
          this.container.style.transform = `translate(${goalX}px, ${goalY}px) scale(${this.scale})`;
          this._translateLast = [goalX, goalY];
      }
      resize(scale) {
      }
      setMouseDownType(type) {
          if (type === 2) {
              this._mouseDownType = 2;
          }
          else if (type === 0) {
              this._mouseDownType = 0;
          }
      }
      recordPosition(x, y) {
          this._mouseDownPosition[0] = x;
          this._mouseDownPosition[1] = y;
      }
      initLineContainer() {
          const svg = createSvg('svg');
          svg.style.width = this.container.getClientRects()[0].width + 'px';
          svg.style.height = this.container.getClientRects()[0].height + 'px';
          svg.style.left = 0;
          svg.style.top = 0;
          this.lineContainer = svg;
          this.container.appendChild(this.lineContainer);
      }
      PreNodeHandler() { }
      ScaleHandler(ev) {
          if (ev.deltaY < 0) {
              if (this.scale >= 1)
                  return;
              this.scale += 0.1;
              this.container.style.transformOrigin = `${ev.x}px ${ev.y}px`;
              this._transform.transformOrigin = `${ev.x}px ${ev.y}px`;
              this.container.style.transform = `translate(${this._transform.translate[0]}px, ${this._transform.translate[1]}px) scale(${this.scale})`;
          }
          else {
              if (this.scale < 0.3)
                  return;
              this.scale -= 0.1;
              this.container.style.transformOrigin = `${ev.x}px ${ev.y}px`;
              this._transform.transformOrigin = `${ev.x}px ${ev.y}px`;
              this.container.style.transform = `translate(${this._transform.translate[0]}px, ${this._transform.translate[1]}px) scale(${this.scale})`;
          }
      }
      NodeMoveHandler(ev) {
          this.currentTarget.position = {
              x: ev.clientX - this._mouseDownPosition[0] + this._mouseDownPosition[2],
              y: ev.clientY - this._mouseDownPosition[1] + this._mouseDownPosition[3],
          };
      }
      NodeActiveHandler(node) {
          this.currentEventType = exports.EditorEventType.NodeActive;
          this.currentTarget = node;
          this._mouseDownPosition[0] = 0;
          this._mouseDownPosition[1] = 0;
          this._mouseDownPosition[2] = node.x;
          this._mouseDownPosition[3] = node.y;
      }
      getScaleOffset(x, y) {
          const originOffset = this._transform.transformOrigin
              .replace(/px/g, '')
              .split(' ');
          const xc = +originOffset[0];
          const yc = +originOffset[1];
          const m1 = [1, 0, 0, 0, 1, 0, xc, yc, 1];
          const m2 = [1 / this.scale, 0, 0, 0, 1 / this.scale, 0, 0, 0, 1];
          const m3 = [1, 0, 0, 0, 1, 0, -xc, -yc, 1];
          let m4 = [0, 0, 0, 0, 0, 0, 0, 0, 0];
          let m5 = [0, 0, 0, 0, 0, 0, 0, 0, 0];
          multiply(m4, m1, m2);
          multiply(m5, m4, m3);
          const r = [0, 0];
          transformMat3(r, [x, y], m5);
          return [...r];
      }
  }

  class Label {
      constructor(options) {
          this._text = '';
          this.instance = createSpan();
          this.instance.setAttribute('class', 'wb-param-label');
          if (options.text) {
              this.text = options.text;
          }
          else {
              this.text = '未命名';
          }
      }
      get text() {
          return this._text;
      }
      set text(value) {
          this._text = value;
          this.instance.innerText = value;
      }
  }

  const getColor = (type) => {
      let color;
      switch (type) {
          case 'string':
              color = '#f703cf';
              break;
          case 'boolean':
              color = '#8e020b';
              break;
          case 'object':
              color = '#20a5e8';
              break;
          case 'number':
              color = '#a4fa60';
              break;
      }
      return color;
  };
  class ParamPoint {
      constructor(options) {
          this.uid = uuid();
          this.type = options.type;
          this.init();
      }
      init() {
          const svg = createSvg('svg');
          svg.setAttribute('class', 'wb-inputPoint-' + this.type);
          const circle = createSvg('circle');
          circle.setAttribute('cx', '5');
          circle.setAttribute('cy', '5');
          circle.setAttribute('r', '4');
          circle.setAttribute('stroke-width', '1px');
          circle.setAttribute('fill', 'none');
          const color = getColor(this.type);
          circle.setAttribute('stroke', color);
          svg.appendChild(circle);
          this.instance = svg;
      }
      update() {
      }
  }

  class Param {
      constructor(options) {
          this.uid = uuid();
          this.type = '';
          this.type = options.type;
          this.create();
      }
      create() {
          this.instance = createDiv();
          this.instance.setAttribute('class', 'wb-param-base');
          this.point = new ParamPoint({ type: this.type });
          this.label = new Label({});
          this.add(this.point);
          this.add(this.label);
      }
      add(ele) {
          this.instance.appendChild(ele.instance);
      }
  }

  class Node extends BaseNode {
      constructor(params) {
          super();
          this.headerClass = 'wb-container-base-header';
          this.active = false;
          this.nodeName = params.nodeName;
          if (params.headerClass) {
              this.headerClass = params.headerClass;
          }
          if (params.color) {
              this.color = params.color;
          }
          this.initContainer();
          this.initHeader();
          this.initBody();
          this.initPrePoint();
          this.initNextPoint();
          this.instance.appendChild(this.header);
          this.instance.appendChild(this.body);
          this.leftBody.appendChild(this.prePoint);
          this.rightBody.appendChild(this.nextPoint);
          if (params.input && params.input.length > 0) {
              params.input.forEach((item) => {
                  this.addInput(this.initInput(item.type));
              });
          }
          this.x = params.x || 0;
          this.y = params.y || 0;
      }
      initContainer() {
          const div = createDiv();
          div.className = 'wb-container-base';
          this.instance = div;
          this.instance.addEventListener('mousedown', () => {
              IO.emit('NodeActive', this);
          });
          this.instance.addEventListener('mouseup', () => {
              IO.emit('NodeInactive', this);
          });
      }
      initHeader() {
          const div = createDiv();
          div.className = this.headerClass;
          div.innerText = this.nodeName;
          if (this.color) {
              div.style.backgroundColor = this.color;
          }
          this.header = div;
      }
      initBody() {
          const div = createDiv();
          div.className = 'wb-container-base-body';
          const left = createDiv();
          left.className = 'wb-container-base-body-left';
          const right = createDiv();
          right.className = 'wb-container-base-body-right';
          div.appendChild(left);
          div.appendChild(right);
          this.leftBody = left;
          this.rightBody = right;
          this.body = div;
      }
      initPrePoint() {
          const svg = createSvg('svg');
          svg.setAttribute('class', 'wb-prePoint');
          const polygon = createSvg('polygon');
          polygon.setAttribute('points', '0,0 0,10 5,10 9,5 5,0');
          polygon.setAttribute('stroke-width', '2px');
          polygon.setAttribute('stroke', 'white');
          polygon.setAttribute('fill', 'none');
          svg.appendChild(polygon);
          svg.addEventListener('mousedown', (ev) => {
              ev.cancelBubble = true;
          });
          svg.addEventListener('mouseup', (ev) => {
              ev.cancelBubble = true;
          });
          svg.addEventListener('click', (ev) => {
              ev.cancelBubble = true;
              IO.emit('ConnectPointClick', {
                  pos: this.getPrePointPosition(),
                  node: this,
                  isPre: true,
              });
          });
          svg.addEventListener('mouseenter', () => {
              IO.emit('ConnectPointEnter', {
                  node: this,
                  isPre: true,
              });
          });
          svg.addEventListener('mouseleave', () => {
              IO.emit('ConnectPointLeave', {
                  node: this,
                  isPre: true,
              });
          });
          this.prePoint = svg;
      }
      initNextPoint() {
          const svg = createSvg('svg');
          svg.setAttribute('class', 'wb-nextPoint');
          const polygon = createSvg('polygon');
          polygon.setAttribute('points', '0,0 0,10 5,10 9,5 5,0');
          polygon.setAttribute('stroke-width', '2px');
          polygon.setAttribute('stroke', 'white');
          polygon.setAttribute('fill', 'none');
          svg.appendChild(polygon);
          svg.addEventListener('mousedown', (ev) => {
              ev.cancelBubble = true;
          });
          svg.addEventListener('mouseup', (ev) => {
              ev.cancelBubble = true;
          });
          svg.addEventListener('click', (ev) => {
              ev.cancelBubble = true;
              IO.emit('ConnectPointClick', {
                  pos: this.getNextPointPosition(),
                  node: this,
                  isPre: false,
              });
          });
          this.nextPoint = svg;
      }
      initInput(type) {
          const box = new Param({ type });
          return box;
      }
      addInput(param) {
          this.inputPoints.push(param);
          this.leftBody.appendChild(param.instance);
      }
      get x() {
          return this._x;
      }
      set x(value) {
          this._x = value;
          this.instance.style.left = `${this._x}px`;
      }
      get y() {
          return this._y;
      }
      set y(value) {
          this._y = value;
          this.instance.style.top = `${this._y}px`;
      }
      get position() {
          return {
              x: this._x,
              y: this._y,
          };
      }
      set position(pos) {
          this.x = pos.x;
          this.y = pos.y;
          this.updateRelativeLines(pos.x, pos.y);
      }
      connect(info) {
          if (info.isPre) {
              this.preNodes.push(info.node);
              const inside = this.prePoint.childNodes[0];
              inside.setAttribute('fill', 'white');
              this.preLines.push(info.line);
              info.line.endNode = this;
          }
          else {
              this.nextNodes.push(info.node);
              const inside = this.nextPoint.childNodes[0];
              inside.setAttribute('fill', 'white');
              this.nextLines.push(info.line);
              info.line.beginNode = this;
          }
      }
      updateRelativeLines(x, y) {
          const [ix, iy] = this.getPrePointPosition();
          this.preLines.forEach((line) => {
              if (line.beginNode.nodeId === this.nodeId) {
                  line.update(new Point(ix, iy), line._end);
              }
              else {
                  line.update(line._begin, new Point(ix, iy));
              }
          });
          this.nextLines.forEach((line) => {
              const [ix, iy] = this.getNextPointPosition();
              if (line.beginNode.nodeId === this.nodeId) {
                  line.update(new Point(ix, iy), line._end);
              }
              else {
                  line.update(line._begin, new Point(ix, iy));
              }
          });
      }
  }

  class BaseLine {
      constructor() {
          this._color = 'white';
      }
      _getControlPoint(begin, end) {
          const middlePoint = begin.middileWith(end);
          if (begin.x < end.x) {
              return [middlePoint.x, begin.y, middlePoint.x, end.y];
          }
          else {
              return [
                  begin.x + begin.x - middlePoint.x,
                  begin.y,
                  end.x - (middlePoint.x - end.x),
                  end.y,
              ];
          }
      }
      _setSize() {
          this._width = Math.abs(this._end.x - this._begin.x);
          this._height = Math.abs(this._end.y - this._begin.y);
      }
  }

  class Line extends BaseLine {
      constructor(begin, end, options = {}) {
          super();
          if (options.color)
              this._color = options.color;
          const Path = createSvg('path');
          this.instance = Path;
          Path.setAttribute('stroke-width', '2px');
          Path.setAttribute('stroke', this.color);
          Path.setAttribute('fill', 'none');
          this.update(begin, end);
      }
      get color() {
          return this._color;
      }
      set color(value) {
          this._color = value;
          this.instance.setAttribute('stroke', value);
      }
      update(begin, end) {
          const cp = this._getControlPoint(begin, end);
          this._begin = begin;
          this._end = end;
          this._setSize();
          const path = `M${begin.x},${begin.y} C${cp[0]},${cp[1]} ${cp[2]},${cp[3]} ${end.x},${end.y}`;
          this.instance.setAttribute('d', path);
      }
      destory() {
          this.instance.parentNode.removeChild(this.instance);
      }
  }

  exports.BaseNode = BaseNode;
  exports.BluePrintEditor = BluePrintEditor;
  exports.Line = Line;
  exports.Node = Node;
  exports.Point = Point;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({});
