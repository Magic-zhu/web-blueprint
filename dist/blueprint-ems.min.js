class BaseNode {
    constructor() {
        this.inputPoints = [];
        this.outPutPoints = [];
        this.variables = {};
        this.nodeName = "Function Name";
        this.async = false;
        this.preNode = [];
        this.nextNode = [];
    }
    execute() {
        console.log(this);
        this.func(this.inputPoints);
        this.nextNode.forEach(item => {
            item.execute();
        });
    }
}

class IO {
    constructor() { }
    static on(eventName, listener, options = {}) {
        if (eventName === undefined || listener === undefined) {
            console.error('event or listener is required!');
            return;
        }
        if (!(eventName in this._events)) {
            this._events[eventName] = [];
        }
        if (this._events[eventName].length >= this.MAX_LISTENERS) {
            console.error(`${eventName}'s number of listeners has reached the limit`);
            return;
        }
        this._events[eventName].push({
            handler: listener,
            once: options.once != undefined ? options.once : false,
        });
    }
    static emit(eventName, ...args) {
        if (!(eventName in this._events)) {
            return false;
        }
        const listeners = this._events[eventName];
        try {
            listeners.forEach((eventTarget) => {
                eventTarget.handler(...args);
                if (eventTarget.once) {
                    this.removeListener(eventName, eventTarget.handler);
                }
            });
        }
        catch (error) {
            console.error(error);
        }
    }
    static once(eventName, listener) {
        this.on(eventName, listener, { once: true });
    }
    static off(eventName, listener) {
        this.removeListener(eventName, listener);
    }
    static removeListener(eventName, listener) {
        if (!(eventName in this._events)) {
            console.warn(`there is no event named ${eventName}`);
            return false;
        }
        let listenerIndex = null;
        for (let i = 0, l = this._events[eventName].length; i < l; i++) {
            if (this._events[eventName][i].handler === listener) {
                listenerIndex = i;
                break;
            }
        }
        if (listenerIndex !== null) {
            this._events[eventName].splice(listenerIndex, 1);
        }
    }
    static removeAllListener(eventName) {
        if (this._events[eventName] === undefined) {
            console.warn(`there is no event named ${eventName}`);
            return false;
        }
        this._events[eventName] = [];
    }
    static setMaxListeners(num) {
        this.MAX_LISTENERS = num;
    }
    static clear() {
        this._events = Object.create(null);
    }
}
IO._events = Object.create(null);
IO.MAX_LISTENERS = 200;

class BluePrintEditor {
    constructor(container) {
        this.scale = 1;
        this.container = container;
        container.style.position = 'relative';
        container.style.transform = 'scale(1)';
        this.container.addEventListener('mouseup', (ev) => {
            IO.emit('mouseup', ev);
        });
        this.container.addEventListener('mousemove', (ev) => {
            IO.emit('mousemove', ev);
        });
        this.container.addEventListener('mousewheel', (ev) => {
            this.container.style.transform;
            if (ev.deltaY < 0) {
                this.scale += 0.1;
                this.container.style.transform = `scale(${this.scale})`;
            }
            else {
                this.scale -= 0.1;
                this.container.style.transform = `scale(${this.scale})`;
            }
        });
        this.init();
    }
    init() {
    }
    add(node) {
        this.container.appendChild(node.container);
    }
}

const createDom = (tag) => {
    return document.createElement(tag);
};
const createDiv = () => {
    return createDom('div');
};
const createSvg = (tag) => {
    return document.createElementNS("http://www.w3.org/2000/svg", tag);
};

class Node extends BaseNode {
    constructor(params) {
        super();
        this.headerClass = "theme-container-base-header";
        this.active = false;
        this.nodeName = params.nodeName;
        if (params.headerClass) {
            this.headerClass = params.headerClass;
        }
        if (params.color) {
            this.color = params.color;
        }
        this.initContainer();
        this.initHeader();
        this.initBody();
        this.initPrePoint();
        this.initNextPoint();
        this.container.appendChild(this.header);
        this.container.appendChild(this.body);
        this.leftBody.appendChild(this.prePoint);
        this.rightBody.appendChild(this.nextPoint);
    }
    initContainer() {
        const div = createDiv();
        div.className = 'theme-container-base';
        this.container = div;
    }
    initHeader() {
        const div = createDiv();
        div.className = this.headerClass;
        div.innerText = this.nodeName;
        if (this.color) {
            div.style.backgroundColor = this.color;
        }
        this.header = div;
    }
    initBody() {
        const div = createDiv();
        div.className = "theme-container-base-body";
        const left = createDiv();
        left.className = "theme-container-base-body-left";
        const right = createDiv();
        right.className = "theme-container-base-body-right";
        div.appendChild(left);
        div.appendChild(right);
        this.leftBody = left;
        this.rightBody = right;
        this.body = div;
    }
    initPrePoint() {
        const svg = createSvg("svg");
        svg.setAttribute('class', 'prePoint');
        const polygon = createSvg("polygon");
        polygon.setAttribute("points", "0,0 0,10 5,10 9,5 5,0");
        polygon.setAttribute("stroke-width", "2px");
        polygon.setAttribute("stroke", "white");
        polygon.setAttribute("fill", "none");
        svg.appendChild(polygon);
        this.prePoint = svg;
    }
    initNextPoint() {
        const svg = createSvg("svg");
        svg.setAttribute('class', 'nextPoint');
        const polygon = createSvg("polygon");
        polygon.setAttribute("points", "0,0 0,10 5,10 9,5 5,0");
        polygon.setAttribute("stroke-width", "2px");
        polygon.setAttribute("stroke", "white");
        polygon.setAttribute("fill", "none");
        svg.appendChild(polygon);
        this.nextPoint = svg;
    }
    initInput() {
    }
    addInput() {
    }
}

export { BaseNode, BluePrintEditor, Node };
