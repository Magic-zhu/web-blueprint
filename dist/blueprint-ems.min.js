const map = '123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function uuid() {
    let ranStr = '';
    for (let i = 0; i < 19; i++) {
        ranStr += map[Math.floor(Math.random() * (48 + 9))];
    }
    return ranStr + new Date().getTime();
}

class BaseNode {
    constructor() {
        this.inputPoints = [];
        this.outPutPoints = [];
        this.variables = {};
        this.nodeName = 'Function Name';
        this.nodeType = 'Function';
        this.nodeId = uuid();
        this.async = false;
        this._x = 0;
        this._y = 0;
        this.preNodes = [];
        this.nextNodes = [];
        this.preLines = [];
        this.nextLines = [];
    }
    execute() {
        this.func(this.inputPoints);
        this.nextNodes.forEach((item) => {
            item.execute();
        });
    }
    getPrePointPosition() {
        return [this._x + 10, this._y + 32 + 10];
    }
}

class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    middileWith(p) {
        const mx = (this.x + p.x) / 2;
        const my = (this.y + p.y) / 2;
        return new Point(mx, my);
    }
    distanceWith(p) {
        return Math.pow((p.x - this.x) * (p.x - this.x) + (p.y - this.y) * (p.y - this.y), 0.5);
    }
}

class IO {
    constructor() { }
    static on(eventName, listener, options = {}) {
        if (eventName === undefined || listener === undefined) {
            console.error('event or listener is required!');
            return;
        }
        if (!(eventName in this._events)) {
            this._events[eventName] = [];
        }
        if (this._events[eventName].length >= this.MAX_LISTENERS) {
            console.error(`${eventName}'s number of listeners has reached the limit`);
            return;
        }
        this._events[eventName].push({
            handler: listener,
            once: options.once != undefined ? options.once : false,
        });
    }
    static emit(eventName, ...args) {
        if (!(eventName in this._events)) {
            return false;
        }
        const listeners = this._events[eventName];
        try {
            listeners.forEach((eventTarget) => {
                eventTarget.handler(...args);
                if (eventTarget.once) {
                    this.removeListener(eventName, eventTarget.handler);
                }
            });
        }
        catch (error) {
            console.error(error);
        }
    }
    static once(eventName, listener) {
        this.on(eventName, listener, { once: true });
    }
    static off(eventName, listener) {
        this.removeListener(eventName, listener);
    }
    static removeListener(eventName, listener) {
        if (!(eventName in this._events)) {
            console.warn(`there is no event named ${eventName}`);
            return false;
        }
        let listenerIndex = null;
        for (let i = 0, l = this._events[eventName].length; i < l; i++) {
            if (this._events[eventName][i].handler === listener) {
                listenerIndex = i;
                break;
            }
        }
        if (listenerIndex !== null) {
            this._events[eventName].splice(listenerIndex, 1);
        }
    }
    static removeAllListener(eventName) {
        if (this._events[eventName] === undefined) {
            console.warn(`there is no event named ${eventName}`);
            return false;
        }
        this._events[eventName] = [];
    }
    static setMaxListeners(num) {
        this.MAX_LISTENERS = num;
    }
    static clear() {
        this._events = Object.create(null);
    }
}
IO._events = Object.create(null);
IO.MAX_LISTENERS = 200;

const createDom = (tag) => {
    return document.createElement(tag);
};
const createDiv = () => {
    return createDom('div');
};
const createSvg = (tag) => {
    return document.createElementNS("http://www.w3.org/2000/svg", tag);
};

var MouseDownType;
(function (MouseDownType) {
    MouseDownType[MouseDownType["LEFT"] = 0] = "LEFT";
    MouseDownType[MouseDownType["RIGHT"] = 2] = "RIGHT";
    MouseDownType[MouseDownType["NONE"] = -1] = "NONE";
})(MouseDownType || (MouseDownType = {}));
var EditorEventType;
(function (EditorEventType) {
    EditorEventType["Normal"] = "normal";
    EditorEventType["NodeSelected"] = "NodeSelected";
    EditorEventType["NodeActive"] = "NodeActive";
    EditorEventType["LineBegin"] = "LineBegin";
    EditorEventType["LineEnd"] = "LineEnd";
})(EditorEventType || (EditorEventType = {}));
class BluePrintEditor {
    constructor(container) {
        this.graph = [];
        this.lineGraph = [];
        this.scale = 1;
        this._orginSize = [];
        this._mouseDownType = -1;
        this._mouseDownPosition = [];
        this._translateLast = [0, 0];
        this._transform = {
            translate: [0, 0],
            transformOrigin: '0px 0px',
        };
        this.currentEventType = EditorEventType.Normal;
        IO.emit('beforeCreated');
        IO.on('NodeSelected', () => { });
        IO.on('NodeActive', (node) => {
            this.currentEventType = EditorEventType.NodeActive;
            this.currentTarget = node;
            this._mouseDownPosition[0] = 0;
            this._mouseDownPosition[1] = 0;
            this._mouseDownPosition[2] = node.x;
            this._mouseDownPosition[3] = node.y;
        });
        IO.on('NodeInactive', () => {
            this.currentEventType = EditorEventType.Normal;
            this.currentTarget = null;
        });
        IO.on('ConnectPointClick', (info) => {
            this.currentTarget = info.node;
            if (this.currentEventType !== EditorEventType.LineBegin) {
                this.currentEventType = EditorEventType.LineBegin;
                const t = new Line(new Point(info.pos[0], info.pos[1]), new Point(info.pos[0], info.pos[1]));
                this.currentLine = t;
                this.addLine(t);
            }
            else {
                this.currentEventType = EditorEventType.LineEnd;
            }
        });
        container.oncontextmenu = function () {
            return false;
        };
        this.container = container;
        this._orginSize[0] = this.container.getClientRects()[0].width;
        this._orginSize[1] = this.container.getClientRects()[0].height;
        container.style.position = 'relative';
        container.style.transform = 'scale(1)';
        this.initLineContainer();
        this.init();
    }
    init() {
        this.container.addEventListener('mousedown', (ev) => {
            this.setMouseDownType(ev.button);
            this.recordPosition(ev.clientX, ev.clientY);
            console.log(ev);
        });
        this.container.addEventListener('mouseup', (ev) => {
            this._mouseDownType = -1;
            this._transform.translate = [...this._translateLast];
            this._mouseDownPosition = [];
            IO.emit('mouseup', ev);
        });
        this.container.addEventListener('mousemove', (ev) => {
            IO.emit('mousemove', ev);
            if (this._mouseDownType == MouseDownType.RIGHT) {
                this.translate(ev);
                return;
            }
            if (this._mouseDownType == MouseDownType.LEFT &&
                this.currentEventType == EditorEventType.NodeActive &&
                this._mouseDownPosition[0] != 0) {
                this.NodeMoveHandler(ev);
            }
            if (this.currentEventType === EditorEventType.LineBegin) {
                this.currentLine.update(this.currentLine._begin, new Point(ev.clientX, ev.clientY));
            }
        });
        this.container.addEventListener('mousewheel', (ev) => {
            this.ScaleHandler(ev);
            this.resize(this.scale);
        });
    }
    add(node) {
        this.container.appendChild(node.container);
        this.graph.push(node);
    }
    addLine(line) {
        this.lineContainer.appendChild(line.instance);
        this.lineGraph.push(line);
    }
    translate(ev) {
        const goalX = ev.clientX - this._mouseDownPosition[0] + this._transform.translate[0];
        const goalY = ev.clientY - this._mouseDownPosition[1] + this._transform.translate[1];
        this.container.style.transform = `translate(${goalX}px, ${goalY}px) scale(${this.scale})`;
        this._translateLast = [goalX, goalY];
    }
    resize(scale) {
        this.container.style.width = this._orginSize[0] * scale + 'px';
        this.container.style.height = this._orginSize[1] * scale + 'px';
    }
    setMouseDownType(type) {
        if (type === 2) {
            this._mouseDownType = 2;
        }
        else if (type === 0) {
            this._mouseDownType = 0;
        }
    }
    recordPosition(x, y) {
        this._mouseDownPosition[0] = x;
        this._mouseDownPosition[1] = y;
    }
    initLineContainer() {
        const svg = createSvg('svg');
        svg.style.width = this.container.getClientRects()[0].width + 'px';
        svg.style.height = this.container.getClientRects()[0].height + 'px';
        svg.style.left = 0;
        svg.style.top = 0;
        this.lineContainer = svg;
        this.container.appendChild(this.lineContainer);
    }
    PreNodeHandler() { }
    ScaleHandler(ev) {
        if (ev.deltaY < 0) {
            this.scale += 0.1;
            this.container.style.transformOrigin = `${ev.x}px ${ev.y}px`;
            this.container.style.transform = `translate(${this._transform.translate[0]}px, ${this._transform.translate[1]}px) scale(${this.scale})`;
        }
        else {
            this.scale -= 0.1;
            this.container.style.transformOrigin = `${ev.x}px ${ev.y}px`;
            this.container.style.transform = `translate(${this._transform.translate[0]}px, ${this._transform.translate[1]}px) scale(${this.scale})`;
        }
    }
    NodeMoveHandler(ev) {
        this.currentTarget.x =
            ev.clientX - this._mouseDownPosition[0] + this._mouseDownPosition[2];
        this.currentTarget.y =
            ev.clientY - this._mouseDownPosition[1] + this._mouseDownPosition[3];
    }
}

class Node extends BaseNode {
    constructor(params) {
        super();
        this.headerClass = 'wb-container-base-header';
        this.active = false;
        this.nodeName = params.nodeName;
        if (params.headerClass) {
            this.headerClass = params.headerClass;
        }
        if (params.color) {
            this.color = params.color;
        }
        this.initContainer();
        this.initHeader();
        this.initBody();
        this.initPrePoint();
        this.initNextPoint();
        this.container.appendChild(this.header);
        this.container.appendChild(this.body);
        this.leftBody.appendChild(this.prePoint);
        this.rightBody.appendChild(this.nextPoint);
        if (params.input && params.input.length > 0) {
            params.input.forEach((item) => {
                this.leftBody.appendChild(this.initInput(item.type));
            });
        }
        this.x = params.x || 0;
        this.y = params.y || 0;
    }
    initContainer() {
        const div = createDiv();
        div.className = 'wb-container-base';
        this.container = div;
        this.container.addEventListener('mousedown', () => {
            IO.emit('NodeActive', this);
        });
        this.container.addEventListener('mouseup', () => {
            IO.emit('NodeInactive', this);
        });
    }
    initHeader() {
        const div = createDiv();
        div.className = this.headerClass;
        div.innerText = this.nodeName;
        if (this.color) {
            div.style.backgroundColor = this.color;
        }
        this.header = div;
    }
    initBody() {
        const div = createDiv();
        div.className = 'wb-container-base-body';
        const left = createDiv();
        left.className = 'wb-container-base-body-left';
        const right = createDiv();
        right.className = 'wb-container-base-body-right';
        div.appendChild(left);
        div.appendChild(right);
        this.leftBody = left;
        this.rightBody = right;
        this.body = div;
    }
    initPrePoint() {
        const svg = createSvg('svg');
        svg.setAttribute('class', 'prePoint');
        const polygon = createSvg('polygon');
        polygon.setAttribute('points', '0,0 0,10 5,10 9,5 5,0');
        polygon.setAttribute('stroke-width', '2px');
        polygon.setAttribute('stroke', 'white');
        polygon.setAttribute('fill', 'none');
        svg.appendChild(polygon);
        svg.addEventListener('click', (ev) => {
            ev.cancelBubble = true;
            IO.emit('ConnectPointClick', {
                pos: this.getPrePointPosition(),
                node: this,
            });
        });
        this.prePoint = svg;
    }
    initNextPoint() {
        const svg = createSvg('svg');
        svg.setAttribute('class', 'nextPoint');
        const polygon = createSvg('polygon');
        polygon.setAttribute('points', '0,0 0,10 5,10 9,5 5,0');
        polygon.setAttribute('stroke-width', '2px');
        polygon.setAttribute('stroke', 'white');
        polygon.setAttribute('fill', 'none');
        svg.appendChild(polygon);
        this.nextPoint = svg;
    }
    initInput(type) {
        const svg = createSvg('svg');
        svg.setAttribute('class', 'wb-inputPoint-' + type);
        const circle = createSvg('circle');
        circle.setAttribute('cx', '5');
        circle.setAttribute('cy', '5');
        circle.setAttribute('r', '4');
        circle.setAttribute('stroke-width', '1px');
        circle.setAttribute('fill', 'none');
        const color = this.getColor(type);
        circle.setAttribute('stroke', color);
        svg.appendChild(circle);
        return svg;
    }
    addInput() { }
    getColor(type) {
        let color;
        switch (type) {
            case 'string':
                color = '#f703cf';
                break;
            case 'boolean':
                color = '#8e020b';
                break;
            case 'object':
                color = '#20a5e8';
                break;
            case 'number':
                color = '#a4fa60';
                break;
        }
        return color;
    }
    get x() {
        return this._x;
    }
    set x(value) {
        this._x = value;
        this.container.style.left = `${this._x}px`;
    }
    get y() {
        return this._y;
    }
    set y(value) {
        this._y = value;
        this.container.style.top = `${this._y}px`;
    }
}

class BaseLine {
    constructor() {
        this.color = 'white';
    }
    _getControlPoint(begin, end) {
        const middlePoint = begin.middileWith(end);
        if (begin.x < end.x) {
            return [middlePoint.x, begin.y, middlePoint.x, end.y];
        }
        else {
            return [
                begin.x + begin.x - middlePoint.x,
                begin.y,
                end.x - (middlePoint.x - end.x),
                end.y,
            ];
        }
    }
    _setSize() {
        this._width = Math.abs(this._end.x - this._begin.x);
        this._height = Math.abs(this._end.y - this._begin.y);
    }
}

class Line extends BaseLine {
    constructor(begin, end) {
        super();
        const Path = createSvg('path');
        this.instance = Path;
        Path.setAttribute('stroke-width', '2px');
        Path.setAttribute('stroke', 'white');
        Path.setAttribute('fill', 'none');
        this.update(begin, end);
    }
    update(begin, end) {
        const cp = this._getControlPoint(begin, end);
        this._begin = begin;
        this._end = end;
        this._setSize();
        const path = `M${begin.x},${begin.y} C${cp[0]},${cp[1]} ${cp[2]},${cp[3]} ${end.x},${end.y}`;
        this.instance.setAttribute('d', path);
    }
}

export { BaseNode, BluePrintEditor, EditorEventType, Line, MouseDownType, Node, Point };
