const map = '123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function uuid() {
    let ranStr = '';
    for (let i = 0; i < 19; i++) {
        ranStr += map[Math.floor(Math.random() * (48 + 9))];
    }
    return ranStr + new Date().getTime();
}

var ClassType;
(function (ClassType) {
    ClassType["LINE"] = "Line";
    ClassType["NODE"] = "Node";
    ClassType["PARAM"] = "Param";
})(ClassType || (ClassType = {}));

class BaseNode {
    constructor() {
        this.classType = ClassType.NODE;
        this.inputPoints = [];
        this.outPutPoints = [];
        this.variables = {};
        this.nodeName = 'Function Name';
        this.nodeType = 'Function';
        this._nodeLabel = '';
        this.nodeBaseWidth = 250;
        this.nodeId = uuid();
        this.async = false;
        this._x = 0;
        this._y = 0;
        this.preNodeRequired = true;
        this.nextNodeRequired = true;
        this.yAxisPak = 10;
        this.preNodes = [];
        this.nextNodes = [];
        this.preLines = [];
        this.nextLines = [];
    }
    execute() {
        this.func(this.inputPoints, this.outPutPoints);
        this.nextNodes.forEach((item) => {
            item.execute();
        });
    }
    getPrePointPosition() {
        return [this._x + 10, this._y + 32 + 10 + 5];
    }
    getNextPointPosition() {
        return [this._x + 250 - 10, this._y + 32 + 10 + 5];
    }
    getParamPosition(index, isInput = true) {
        if (isInput) {
            return [this._x + 10, this._y + 32 + 25 + 20 * index + this.yAxisPak];
        }
        else {
            return [this._x + 250, this._y + 32 + 25 + 20 * index + this.yAxisPak];
        }
    }
}

class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    middileWith(p) {
        const mx = (this.x + p.x) / 2;
        const my = (this.y + p.y) / 2;
        return new Point(mx, my);
    }
    distanceWith(p) {
        return Math.pow((p.x - this.x) * (p.x - this.x) + (p.y - this.y) * (p.y - this.y), 0.5);
    }
}

var NodeConnectType;
(function (NodeConnectType) {
    NodeConnectType[NodeConnectType["PRE"] = 0] = "PRE";
    NodeConnectType[NodeConnectType["NEXT"] = 1] = "NEXT";
})(NodeConnectType || (NodeConnectType = {}));
class BaseLine {
    constructor() {
        this.classType = ClassType.LINE;
        this._color = 'white';
        this.id = uuid();
    }
    _getControlPoint(begin, end) {
        const middlePoint = begin.middileWith(end);
        if (begin.x < end.x) {
            return [middlePoint.x, begin.y, middlePoint.x, end.y];
        }
        else {
            return [
                begin.x + begin.x - middlePoint.x,
                begin.y,
                end.x - (middlePoint.x - end.x),
                end.y,
            ];
        }
    }
    _setSize() {
        this._width = Math.abs(this._end.x - this._begin.x);
        this._height = Math.abs(this._end.y - this._begin.y);
    }
}

const createDom = (tag) => {
    return document.createElement(tag);
};
const createDiv = () => {
    return createDom('div');
};
const createSvg = (tag) => {
    return document.createElementNS('http://www.w3.org/2000/svg', tag);
};
const createInputNumberBox = () => {
    const input = document.createElement('input');
    input.setAttribute('type', 'number');
    return input;
};
const createInputTextBox = () => {
    const input = document.createElement('input');
    input.setAttribute('type', 'text');
    return input;
};
const createSpan = () => {
    return createDom('span');
};
const createCheckBox = () => {
    const input = document.createElement('input');
    input.setAttribute('type', 'checkbox');
    return input;
};

class Line extends BaseLine {
    constructor(begin, end, options = {}) {
        super();
        if (options.color)
            this._color = options.color;
        const Path = createSvg('path');
        this.instance = Path;
        Path.setAttribute('stroke-width', '2px');
        Path.setAttribute('stroke', this.color);
        Path.setAttribute('fill', 'none');
        this.update(begin, end);
    }
    get color() {
        return this._color;
    }
    set color(value) {
        this._color = value;
        this.instance.setAttribute('stroke', value);
    }
    update(begin, end) {
        let cp;
        let path;
        if (this.beginNodeConnectType === NodeConnectType.NEXT) {
            cp = this._getControlPoint(begin, end);
            path = `M${begin.x},${begin.y} C${cp[0]},${cp[1]} ${cp[2]},${cp[3]} ${end.x},${end.y}`;
        }
        else {
            cp = this._getControlPoint(end, begin);
            path = `M${end.x},${end.y} C${cp[0]},${cp[1]} ${cp[2]},${cp[3]} ${begin.x},${begin.y}`;
        }
        this._begin = begin;
        this._end = end;
        this._setSize();
        this.instance.setAttribute('d', path);
    }
    destory() {
        try {
            this.instance.parentNode.removeChild(this.instance);
        }
        catch (error) { }
    }
}

class IO {
    constructor() { }
    static on(eventName, listener, options = {}) {
        if (eventName === undefined || listener === undefined) {
            console.error('event or listener is required!');
            return;
        }
        if (!(eventName in this._events)) {
            this._events[eventName] = [];
        }
        if (this._events[eventName].length >= this.MAX_LISTENERS) {
            console.error(`${eventName}'s number of listeners has reached the limit`);
            return;
        }
        if (options.only) {
            if (this._events[eventName].length !== 0) {
                return;
            }
        }
        this._events[eventName].push({
            handler: listener,
            once: options.once != undefined ? options.once : false,
        });
    }
    static emit(eventName, ...args) {
        if (!(eventName in this._events)) {
            return false;
        }
        const listeners = this._events[eventName];
        try {
            listeners.forEach((eventTarget) => {
                eventTarget.handler(...args);
                if (eventTarget.once) {
                    this.removeListener(eventName, eventTarget.handler);
                }
            });
        }
        catch (error) {
            console.error(error);
        }
    }
    static once(eventName, listener) {
        this.on(eventName, listener, { once: true });
    }
    static off(eventName, listener) {
        this.removeListener(eventName, listener);
    }
    static removeListener(eventName, listener) {
        if (!(eventName in this._events)) {
            console.warn(`there is no event named ${eventName}`);
            return false;
        }
        let listenerIndex = null;
        for (let i = 0, l = this._events[eventName].length; i < l; i++) {
            if (this._events[eventName][i].handler === listener) {
                listenerIndex = i;
                break;
            }
        }
        if (listenerIndex !== null) {
            this._events[eventName].splice(listenerIndex, 1);
        }
    }
    static removeAllListener(eventName) {
        if (this._events[eventName] === undefined) {
            console.warn(`there is no event named ${eventName}`);
            return false;
        }
        this._events[eventName] = [];
    }
    static setMaxListeners(num) {
        this.MAX_LISTENERS = num;
    }
    static clear() {
        this._events = Object.create(null);
    }
}
IO._events = Object.create(null);
IO.MAX_LISTENERS = 30;

class Label$1 {
    constructor(options) {
        this._text = '';
        this.instance = createSpan();
        this.instance.setAttribute('class', 'wb-param-label');
        if (options.text) {
            this.text = options.text;
        }
        else {
            this.text = '未命名';
        }
    }
    get text() {
        return this._text;
    }
    set text(value) {
        this._text = value;
        this.instance.innerText = value;
    }
}

const getColor$1 = (type) => {
    let color;
    switch (type) {
        case 'string':
            color = '#f703cf';
            break;
        case 'boolean':
            color = '#8e020b';
            break;
        case 'object':
            color = '#20a5e8';
            break;
        case 'number':
            color = '#a4fa60';
            break;
        case 'process':
            color = 'white';
            break;
        case 'any':
            color = '#eeeeee';
            break;
    }
    return color;
};
class ParamPoint$1 {
    constructor(options) {
        this.uid = uuid();
        this.type = options.type;
        this.init();
    }
    init() {
        const svg = createSvg('svg');
        svg.setAttribute('class', 'wb-inputPoint-' + this.type);
        const color = getColor$1(this.type);
        this.color = color;
        if (this.type === 'process') {
            const polygon = createSvg('polygon');
            polygon.setAttribute('points', '0,0 10,5 0,10');
            polygon.setAttribute('stroke-width', '1px');
            polygon.setAttribute('stroke', 'white');
            polygon.setAttribute('fill', 'none');
            this.inside = polygon;
            svg.appendChild(polygon);
        }
        else {
            const circle = createSvg('circle');
            circle.setAttribute('cx', '5');
            circle.setAttribute('cy', '5');
            circle.setAttribute('r', '4');
            circle.setAttribute('stroke-width', '1px');
            circle.setAttribute('fill', 'none');
            circle.setAttribute('stroke', color);
            this.inside = circle;
            svg.appendChild(circle);
        }
        this.instance = svg;
    }
    update() { }
    connect() {
        this.inside.setAttribute('fill', this.color);
    }
    disConnect() {
        this.inside.setAttribute('fill', 'none');
    }
}

class Input$1 {
    constructor(options) {
        this.type = options.type;
        this.create();
    }
    create() {
        const box = createDiv();
        box.setAttribute('class', 'wb-input-box');
        let inputBox;
        switch (this.type) {
            case 'number':
                inputBox = createInputNumberBox();
                inputBox.setAttribute('class', 'wb-input-number');
                break;
            case 'string':
                inputBox = createInputTextBox();
                inputBox.setAttribute('class', 'wb-input-string');
                break;
            case 'boolean':
                inputBox = createCheckBox();
                inputBox.setAttribute('class', 'wb-input-checkbox');
                break;
            default:
                inputBox = createDiv();
        }
        inputBox.oninput = this.inputChangeHanlde.bind(this);
        box.appendChild(inputBox);
        this.inputIntance = inputBox;
        this.instance = box;
    }
    inputChangeHanlde(v) {
        this.value = this.inputIntance.value;
        this.parent.update(this.value);
    }
    get value() {
        return this._value;
    }
    set value(s) {
        this._value = s;
    }
    hidden() {
        this.instance.style.display = 'none';
    }
    show() {
        this.instance.style.display = '';
    }
}

class Param$1 {
    get value() {
        if (this.isConnected && this.isInput) {
            return this.linkedParam.value;
        }
        return this._value;
    }
    set value(value) {
        this._value = value;
    }
    constructor(options) {
        this.classType = ClassType.PARAM;
        this.uid = uuid();
        this.type = '';
        this.name = '';
        this._value = '';
        this.isConnected = false;
        this.linkedObjects = [];
        this.type = options.type;
        this.isInput = options.isInput !== undefined ? options.isInput : true;
        this.name = options.name !== undefined ? options.name : 'unknown';
        this.value = options.value !== undefined ? options.value : '';
        this.create();
    }
    create() {
        this.instance = createDiv();
        this.instance.setAttribute('class', 'wb-param-base');
        this.point = new ParamPoint$1({ type: this.type });
        this.label = new Label$1({ text: this.name });
        this.input = new Input$1({ type: this.type });
        this.input.parent = this;
        if (this.isInput) {
            this.add(this.point);
            this.add(this.label);
            this.add(this.input);
        }
        else {
            this.add(this.label);
            this.add(this.point);
        }
    }
    add(ele) {
        this.instance.appendChild(ele.instance);
    }
    connect(line, wpElement, position) {
        if (wpElement.classType === ClassType.NODE) {
            const node = wpElement;
            this.point.connect();
            this.isConnected = true;
            this.linkedObjects.push({
                line,
                node,
                id: node.nodeId,
                classType: ClassType.NODE,
            });
            if (position === 'begin') {
                this.isBeign = true;
            }
            else {
                this.isBeign = false;
            }
        }
        if (wpElement.classType === ClassType.PARAM) {
            const param = wpElement;
            if (this.isInput && this.isConnected)
                return;
            this.point.connect();
            this.isConnected = true;
            this.input.hidden();
            if (!this.isInput) {
                this.linkedObjects.push({
                    line,
                    param,
                    id: param.uid,
                    classType: ClassType.PARAM,
                });
            }
            else {
                this.linkedLine = line;
                this.linkedParam = param;
            }
            if (position === 'begin') {
                this.isBeign = true;
            }
            else {
                this.isBeign = false;
            }
            if (this.isInput) {
                this.update(param.value);
            }
        }
    }
    disConnect(paramId) {
        if (this.isInput) {
            this.value = '';
            this.isConnected = false;
            this.input.show();
            this.point.disConnect();
            this.linkedLine.destory();
            this.linkedParam.disConnect(this.uid);
            this.linkedParam = null;
            this.linkedLine = null;
        }
        else {
            const index = this.linkedObjects.findIndex((item) => item.param.uid === paramId);
            if (index === -1)
                return;
            this.linkedObjects[index].line.destory();
            this.linkedObjects.splice(index, 1);
            if (this.linkedObjects.length === 0) {
                this.isConnected = false;
                this.point.disConnect();
            }
        }
    }
    update(value) {
        this.value = value;
    }
}

var ConnectPosition$1;
(function (ConnectPosition) {
    ConnectPosition["BEGIN"] = "begin";
    ConnectPosition["END"] = "END";
})(ConnectPosition$1 || (ConnectPosition$1 = {}));
class Node$1 extends BaseNode {
    constructor(params) {
        super();
        this.headerClass = 'wb-container-base-header';
        this.active = false;
        this._selected = false;
        this.nodeName = params.nodeName;
        if (params.headerClass) {
            this.headerClass = params.headerClass;
        }
        if (params.color) {
            this.color = params.color;
        }
        this.func = params.func;
        this.initContainer();
        this.initHeader();
        this.instance.appendChild(this.header);
        this.initBody();
        this.instance.appendChild(this.body);
        if (params.preNodeRequired || params.preNodeRequired === undefined) {
            this.preNodeRequired = true;
        }
        else {
            this.preNodeRequired = false;
        }
        if (params.nextNodeRequired || params.nextNodeRequired === undefined) {
            this.nextNodeRequired = true;
        }
        else {
            this.nextNodeRequired = false;
        }
        if (this.nextNodeRequired || this.preNodeRequired) {
            this.initPrePoint(this.preNodeRequired);
            this.leftBody.appendChild(this.prePoint);
            this.initNextPoint(this.nextNodeRequired);
            this.rightBody.appendChild(this.nextPoint);
        }
        if (!this.nextNodeRequired && !this.preNodeRequired) {
            this.yAxisPak = 0;
        }
        if (params.input && params.input.length > 0) {
            params.input.forEach((item, index) => {
                this.addInput(this.initInput(item, index));
            });
        }
        if (params.output && params.output.length > 0) {
            params.output.forEach((item, index) => {
                this.addOutput(this.initOutput(item, index));
            });
        }
        this.x = params.x || 0;
        this.y = params.y || 0;
        if (params.nodeLabel) {
            this.initLabel(params.nodeLabel);
        }
    }
    get x() {
        return this._x;
    }
    set x(value) {
        this._x = value;
        this.instance.style.left = `${this._x}px`;
    }
    get y() {
        return this._y;
    }
    set y(value) {
        this._y = value;
        this.instance.style.top = `${this._y}px`;
    }
    get position() {
        return {
            x: this._x,
            y: this._y,
        };
    }
    get width() {
        return this.instance.clientWidth;
    }
    get height() {
        return this.instance.clientHeight;
    }
    get selected() {
        return this._selected;
    }
    set selected(value) {
        if (this._selected === value) {
            return;
        }
        this._selected = value;
        if (value) {
            this.instance.className = this.instance.className + ' ' + 'selected';
        }
        else {
            this.instance.className = this.instance.className.replace(' selected', '');
        }
    }
    set position(pos) {
        this.x = pos.x;
        this.y = pos.y;
        this.updateRelativeLines(pos.x, pos.y);
    }
    get nodeLabel() {
        return this._nodeLabel;
    }
    set nodeLabel(label) {
        this._nodeLabel = label;
    }
    initContainer() {
        const div = createDiv();
        div.className = 'wb-container-base';
        this.instance = div;
        this.instance.addEventListener('mousedown', () => {
            IO.emit('NodeActive', this);
        });
        this.instance.addEventListener('mouseup', () => {
            IO.emit('NodeInactive', this);
        });
    }
    initHeader() {
        const div = createDiv();
        div.className = this.headerClass;
        div.innerText = this.nodeName;
        if (this.color) {
            div.style.background = this.color;
        }
        this.header = div;
    }
    initBody() {
        const div = createDiv();
        div.className = 'wb-container-base-body';
        const left = createDiv();
        left.className = 'wb-container-base-body-left';
        const right = createDiv();
        right.className = 'wb-container-base-body-right';
        div.appendChild(left);
        div.appendChild(right);
        this.leftBody = left;
        this.rightBody = right;
        this.body = div;
    }
    initPrePoint(ifNeed) {
        const svg = createSvg('svg');
        svg.setAttribute('class', 'wb-prePoint');
        if (!ifNeed) {
            this.prePoint = svg;
            return;
        }
        const polygon = createSvg('polygon');
        polygon.setAttribute('points', '0,0 0,10 5,10 9,5 5,0');
        polygon.setAttribute('stroke-width', '2px');
        polygon.setAttribute('stroke', 'white');
        polygon.setAttribute('fill', 'none');
        svg.appendChild(polygon);
        svg.addEventListener('mousedown', (ev) => {
            ev.stopPropagation();
        });
        svg.addEventListener('mouseup', (ev) => {
            ev.stopPropagation();
        });
        svg.addEventListener('click', (ev) => {
            ev.stopPropagation();
            const info = {
                pos: this.getPrePointPosition(),
                node: this,
                isPre: true,
            };
            if (ev.button === 0) {
                IO.emit('ConnectPointClick', info);
                return;
            }
            if (ev.button === 2) {
                IO.emit('ConnectPointRightClick', info);
            }
        });
        svg.addEventListener('mouseenter', () => {
            IO.emit('ConnectPointEnter', {
                node: this,
                isPre: true,
            });
        });
        svg.addEventListener('mouseleave', () => {
            IO.emit('ConnectPointLeave', {
                node: this,
                isPre: true,
            });
        });
        this.prePoint = svg;
    }
    initNextPoint(ifNeed) {
        const svg = createSvg('svg');
        svg.setAttribute('class', 'wb-nextPoint');
        if (!ifNeed) {
            this.nextPoint = svg;
            return;
        }
        const polygon = createSvg('polygon');
        polygon.setAttribute('points', '0,0 0,10 5,10 9,5 5,0');
        polygon.setAttribute('stroke-width', '2px');
        polygon.setAttribute('stroke', 'white');
        polygon.setAttribute('fill', 'none');
        svg.appendChild(polygon);
        svg.addEventListener('mousedown', (ev) => {
            ev.stopPropagation();
        });
        svg.addEventListener('mouseup', (ev) => {
            ev.stopPropagation();
        });
        svg.addEventListener('click', (ev) => {
            ev.stopPropagation();
            IO.emit('ConnectPointClick', {
                pos: this.getNextPointPosition(),
                node: this,
                isPre: false,
            });
        });
        this.nextPoint = svg;
    }
    initInput({ type, value, name }, index) {
        const box = new Param$1({ type, value, name });
        box.instance.addEventListener('mousedown', (ev) => {
            ev.stopPropagation();
        });
        box.instance.addEventListener('mouseup', (ev) => {
            ev.stopPropagation();
        });
        box.point.instance.addEventListener('click', (ev) => {
            IO.emit('ParamPointClick', {
                pos: this.getParamPosition(index),
                node: this,
                param: box,
            });
        });
        return box;
    }
    addInput(param) {
        this.inputPoints.push(param);
        param.parent = this;
        this.leftBody.appendChild(param.instance);
    }
    initOutput({ type, value, name }, index) {
        const box = new Param$1({ type, value, name, isInput: false });
        box.instance.addEventListener('mousedown', (ev) => {
            ev.cancelBubble = true;
        });
        box.instance.addEventListener('mouseup', (ev) => {
            ev.cancelBubble = true;
        });
        box.point.instance.addEventListener('click', (ev) => {
            if (box.type !== 'process') {
                IO.emit('ParamPointClick', {
                    pos: this.getParamPosition(index, false),
                    node: this,
                    param: box,
                });
            }
            else {
                IO.emit('ProcessPointClick', {
                    pos: this.getParamPosition(index, false),
                    node: this,
                    param: box,
                });
            }
        });
        return box;
    }
    addOutput(param) {
        this.outPutPoints.push(param);
        param.parent = this;
        this.rightBody.appendChild(param.instance);
    }
    initLabel(labelText) {
        const label = createSpan();
        label.setAttribute('class', 'wb-container-base-header-label');
        label.innerText = labelText;
        this.header.append(label);
    }
    connect(info, position) {
        if (info.isPre) {
            this.preNodes.push(info.node);
            const inside = this.prePoint.childNodes[0];
            inside.setAttribute('fill', 'white');
            this.preLines.push(info.line);
        }
        else {
            this.nextNodes.push(info.node);
            const inside = this.nextPoint.childNodes[0];
            inside.setAttribute('fill', 'white');
            this.nextLines.push(info.line);
        }
        if (position === ConnectPosition$1.BEGIN) {
            info.line.beginNode = this;
        }
        else {
            info.line.endNode = this;
        }
    }
    updateRelativeLines(x, y) {
        this.preLines.forEach((line) => {
            var _a;
            const [ix, iy] = this.getPrePointPosition();
            if (((_a = line.beginNode) === null || _a === void 0 ? void 0 : _a.nodeId) === this.nodeId) {
                line.update(new Point(ix, iy), line._end);
            }
            else {
                line.update(line._begin, new Point(ix, iy));
            }
        });
        this.nextLines.forEach((line) => {
            var _a;
            const [ix, iy] = this.getNextPointPosition();
            if (((_a = line.beginNode) === null || _a === void 0 ? void 0 : _a.nodeId) === this.nodeId) {
                line.update(new Point(ix, iy), line._end);
            }
            else {
                line.update(line._begin, new Point(ix, iy));
            }
        });
        this.inputPoints.forEach((param, index) => {
            if (!param.linkedLine)
                return;
            const [ix, iy] = this.getParamPosition(index, true);
            if (param.isBeign) {
                param.linkedLine.update(new Point(ix, iy), param.linkedLine._end);
            }
            else {
                param.linkedLine.update(param.linkedLine._begin, new Point(ix, iy));
            }
        });
        this.outPutPoints.forEach((param, index) => {
            if (!param.linkedObjects)
                return;
            const [ix, iy] = this.getParamPosition(index, false);
            if (param.isBeign) {
                param.linkedObjects.forEach((item) => {
                    item.line.update(new Point(ix, iy), item.line._end);
                });
            }
            else {
                param.linkedObjects.forEach((item) => {
                    item.line.update(item.line._begin, new Point(ix, iy));
                });
            }
        });
    }
    disConnect(id, isPre) {
        let relativeNode;
        if (isPre) {
            const index = this.preNodes.findIndex((item) => item.nodeId === id);
            if (index === -1)
                return;
            relativeNode = this.preNodes[index];
            this.preNodes.splice(index, 1);
            const lineIndex = this.preLines.findIndex((item) => {
                return item.beginNode.nodeId === id || item.endNode.nodeId === id;
            });
            if (lineIndex === -1)
                return;
            IO.emit('LineRemove', this.preLines[lineIndex].id);
            this.preLines.splice(lineIndex, 1);
        }
        else {
            const index = this.nextNodes.findIndex((item) => item.nodeId === id);
            if (index === -1)
                return;
            relativeNode = this.nextNodes[index];
            this.nextNodes.splice(index, 1);
            const lineIndex = this.nextLines.findIndex((item) => {
                return item.beginNode.nodeId === id || item.endNode.nodeId === id;
            });
            if (lineIndex === -1)
                return;
            IO.emit('LineRemove', this.nextLines[lineIndex].id);
            this.nextLines.splice(lineIndex, 1);
        }
        this.callRelativeNodeDisconnect(relativeNode, !isPre);
        this.updatePreOrNextConnectedStatus();
    }
    callRelativeNodeDisconnect(node, isPre) {
        node.disConnect(this.nodeId, isPre);
        node.updatePreOrNextConnectedStatus();
    }
    updatePreOrNextConnectedStatus() {
        const child1 = this.prePoint.childNodes[0];
        const child2 = this.nextPoint.childNodes[0];
        if (this.preLines.length === 0) {
            child1.setAttribute('fill', 'none');
        }
        else {
            child1.setAttribute('fill', 'white');
        }
        if (this.nextLines.length === 0) {
            child2.setAttribute('fill', 'none');
        }
        else {
            child2.setAttribute('fill', 'white');
        }
    }
    serialize() {
        const container = {
            nodeId: this.nodeId,
            nodeName: this.nodeName,
            nodeType: this.nodeType,
            x: this.x,
            y: this.y,
        };
        container.preNodeIds = this.preNodes.map((node) => node.nodeId);
        container.nextNodeIds = this.nextNodes.map((node) => node.nodeId);
        container.inputParamsIds = this.inputPoints.map((param) => {
            var _a;
            return (_a = param.linkedParam) === null || _a === void 0 ? void 0 : _a.uid;
        });
        container.outputParamsIds = this.outPutPoints.map((param) => {
            const ar = [];
            param.linkedObjects.forEach((item) => {
                ar.push(item.param.uid);
            });
            return ar;
        });
        return JSON.stringify(container);
    }
}

/**
 * Common utilities
 * @module glMatrix
 */
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new ARRAY_TYPE(2);

  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

(function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
})();

class Selector {
    constructor() {
        this.isHidden = true;
        this.create();
    }
    create() {
        const container = createSvg('svg');
        container.style.position = 'absolute';
        container.style.opacity = '0.5';
        container.style.display = 'none';
        const rec = createSvg('rect');
        rec.setAttribute('width', '0');
        rec.setAttribute('height', '0');
        rec.setAttribute('stroke', '#5352ed');
        rec.setAttribute('stroke-width', '4px');
        rec.setAttribute('fill', '#70a1ff');
        this.inside = rec;
        container.appendChild(rec);
        this.instance = container;
        document.body.appendChild(container);
    }
    update(x, y, width, height) {
        if (width >= 0 && height >= 0) {
            this.instance.style.left = x + 'px';
            this.instance.style.top = y + 'px';
            this.x = x;
            this.y = y;
        }
        if (width < 0 && height < 0) {
            this.instance.style.left = x + width + 'px';
            this.instance.style.top = y + height + 'px';
            this.x = x + width;
            this.y = y + height;
        }
        if (width > 0 && height < 0) {
            this.instance.style.left = x + 'px';
            this.instance.style.top = y + height + 'px';
            this.x = x;
            this.y = y + height;
        }
        if (width < 0 && height > 0) {
            this.instance.style.left = x + width + 'px';
            this.instance.style.top = y + 'px';
            this.x = x + width;
            this.y = y;
        }
        this.instance.style.width = Math.abs(width) + 'px';
        this.instance.style.height = Math.abs(height) + 'px';
        this.width = Math.abs(width);
        this.height = Math.abs(height);
        this.inside.setAttribute('width', `${Math.abs(width)}`);
        this.inside.setAttribute('height', `${Math.abs(height)}`);
    }
    show() {
        this.instance.style.display = 'block';
        this.isHidden = false;
    }
    hidden() {
        this.update(0, 0, 0, 0);
        this.instance.style.display = 'none';
        this.isHidden = true;
    }
}

var Os;
(function (Os) {
    Os["Windows"] = "Windows";
    Os["Mac"] = "Mac";
    Os["Linux"] = "Linux";
})(Os || (Os = {}));

const intersection_rectangle = (x, y, width, height, x2, y2, width2, height2) => {
    const centerX = x + width / 2;
    const centerY = y + height / 2;
    const centerX2 = x2 + width2 / 2;
    const centerY2 = y2 + height2 / 2;
    const x_axis_projection = Math.abs(centerX2 - centerX);
    const y_axis_projection = Math.abs(centerY2 - centerY);
    if ((width + width2) / 2 > x_axis_projection &&
        (height + height2) / 2 > y_axis_projection) {
        return true;
    }
    return false;
};

class LogMsg {
}

var MouseDownType;
(function (MouseDownType) {
    MouseDownType[MouseDownType["LEFT"] = 0] = "LEFT";
    MouseDownType[MouseDownType["RIGHT"] = 2] = "RIGHT";
    MouseDownType[MouseDownType["NONE"] = -1] = "NONE";
})(MouseDownType || (MouseDownType = {}));
var EditorEventType;
(function (EditorEventType) {
    EditorEventType["Normal"] = "normal";
    EditorEventType["NodeActive"] = "NodeActive";
    EditorEventType["LineBegin"] = "LineBegin";
    EditorEventType["LineEnd"] = "LineEnd";
})(EditorEventType || (EditorEventType = {}));
var BeginType;
(function (BeginType) {
    BeginType["NODE"] = "node";
    BeginType["PARAM"] = "param";
    BeginType["PROCESS"] = "process";
})(BeginType || (BeginType = {}));
class BluePrintEditor {
    constructor(container) {
        this.msgLogger = new LogMsg();
        this.graph = [];
        this.lineGraph = [];
        this.scale = 1;
        this._orginSize = [];
        this.left = 0;
        this.top = 0;
        this._mouseDownType = -1;
        this._mouseDownPosition = [];
        this._translateLast = [0, 0];
        this._transform = {
            translate: [0, 0],
            transformOrigin: '0px 0px',
        };
        this.currentEventType = EditorEventType.Normal;
        IO.emit('beforeCreated');
        IO.on('LineRemove', (id) => {
            const index = this.lineGraph.findIndex((item) => item.id);
            if (index === -1)
                return;
            const line = this.lineGraph[index];
            this.lineGraph.splice(index, 1);
            line.destory();
        });
        IO.on('NodeActive', (node) => {
            if (this.currentEventType === EditorEventType.LineBegin)
                return;
            this.NodeActiveHandler(node);
        }, { only: true });
        IO.on('NodeInactive', () => {
            if (this.currentEventType !== EditorEventType.LineBegin) {
                this.currentEventType = EditorEventType.Normal;
            }
            this.currentTarget = null;
        }, { only: true });
        IO.on('ConnectPointClick', (info) => {
            this.handleConnectPointClick(info);
        }, { only: true });
        IO.on('ParamPointClick', (info) => {
            this.paramPointClickHandler(info);
        }, { only: true });
        IO.on('ProcessPointClick', (info) => {
            this.processPointClickHandler(info);
        }, { only: true });
        IO.on('ConnectPointEnter', (info) => { }, { only: true });
        container.oncontextmenu = function () {
            return false;
        };
        this.container = container;
        this._orginSize[0] = this.container.getClientRects()[0].width;
        this._orginSize[1] = this.container.getClientRects()[0].height;
        this.left = this.container.getClientRects()[0].left;
        this.top = this.container.getClientRects()[0].top;
        container.style.position = 'relative';
        container.style.transform = 'scale(1)';
        this.initLineContainer();
        this.init();
    }
    init() {
        this.container.addEventListener('mousedown', (ev) => {
            this.setMouseDownType(ev.button);
            if (this.onRightClick && ev.button === 2) {
                this.onRightClick();
            }
            this.recordPosition(ev.clientX, ev.clientY);
        });
        document.body.addEventListener('mouseup', (ev) => {
            this._mouseDownType = -1;
            this._transform.translate = [...this._translateLast];
            this._mouseDownPosition = [];
            this.selector.hidden();
            if (this.currentEventType === EditorEventType.LineBegin) {
                this.currentLine.destory();
                this.currentLine = null;
                this.currentEventType = EditorEventType.Normal;
                this.resetAfterAttachLine();
            }
        });
        document.body.addEventListener('mousemove', (ev) => {
            if (this._mouseDownType == MouseDownType.RIGHT) {
                this.translate(ev);
                return;
            }
            if (this._mouseDownType == MouseDownType.LEFT &&
                this.currentEventType == EditorEventType.NodeActive &&
                this._mouseDownPosition[0] != 0) {
                this.NodeMoveHandler(ev);
                return;
            }
            if (this.currentEventType === EditorEventType.LineBegin) {
                const [ox, oy] = this.getScaleOffset(this.reviseClientX(ev.clientX) - this._translateLast[0], this.reviseClientY(ev.clientY) - this._translateLast[1]);
                this.currentLine.update(this.currentLine._begin, new Point(ox, oy));
                return;
            }
            if (this._mouseDownType === MouseDownType.LEFT &&
                this.currentEventType === EditorEventType.Normal) {
                const ow = ev.clientX - this._mouseDownPosition[0];
                const oh = ev.clientY - this._mouseDownPosition[1];
                if (this.selector.isHidden === true) {
                    this.selector.show();
                }
                this.selector.update(this._mouseDownPosition[0], this._mouseDownPosition[1], ow, oh);
                this.SelectHandler(this.selector.x, this.selector.y, this.selector.width, this.selector.height);
            }
        });
        this.container.addEventListener('mousewheel', (ev) => {
            this.ScaleHandler(ev);
        });
        this.selector = new Selector();
    }
    add(node) {
        this.container.appendChild(node.instance);
        this.graph.push(node);
    }
    addLine(line) {
        this.lineContainer.appendChild(line.instance);
    }
    translate(ev) {
        const goalX = ev.clientX - this._mouseDownPosition[0] + this._transform.translate[0];
        const goalY = ev.clientY - this._mouseDownPosition[1] + this._transform.translate[1];
        this.container.style.transform = `translate(${goalX}px, ${goalY}px) scale(${this.scale})`;
        this._translateLast = [goalX, goalY];
    }
    setMouseDownType(type) {
        if (type === 2) {
            this._mouseDownType = 2;
        }
        else if (type === 0) {
            this._mouseDownType = 0;
        }
    }
    recordPosition(x, y) {
        this._mouseDownPosition[0] = x;
        this._mouseDownPosition[1] = y;
    }
    initLineContainer() {
        const svg = createSvg('svg');
        svg.style.width = this.container.getClientRects()[0].width + 'px';
        svg.style.height = this.container.getClientRects()[0].height + 'px';
        svg.style.left = 0;
        svg.style.top = 0;
        this.lineContainer = svg;
        this.container.appendChild(this.lineContainer);
    }
    PreNodeHandler() { }
    ScaleHandler(ev) {
        if (ev.deltaY < 0) {
            if (this.scale >= 1)
                return;
            this.scale += 0.1;
            this.container.style.transformOrigin = `${ev.x}px ${ev.y}px`;
            this._transform.transformOrigin = `${ev.x}px ${ev.y}px`;
            this.container.style.transform = `translate(${this._transform.translate[0]}px, ${this._transform.translate[1]}px) scale(${this.scale})`;
        }
        else {
            if (this.scale <= 0.7)
                return;
            this.scale -= 0.1;
            this.container.style.transformOrigin = `${ev.x}px ${ev.y}px`;
            this._transform.transformOrigin = `${ev.x}px ${ev.y}px`;
            this.container.style.transform = `translate(${this._transform.translate[0]}px, ${this._transform.translate[1]}px) scale(${this.scale})`;
        }
    }
    NodeMoveHandler(ev) {
        this.currentTarget.position = {
            x: ev.clientX - this._mouseDownPosition[0] + this._mouseDownPosition[2],
            y: ev.clientY - this._mouseDownPosition[1] + this._mouseDownPosition[3],
        };
    }
    NodeActiveHandler(node) {
        this.currentEventType = EditorEventType.NodeActive;
        this.currentTarget = node;
        this._mouseDownPosition[0] = 0;
        this._mouseDownPosition[1] = 0;
        this._mouseDownPosition[2] = node.x;
        this._mouseDownPosition[3] = node.y;
    }
    getScaleOffset(x, y) {
        const originOffset = this._transform.transformOrigin
            .replace(/px/g, '')
            .split(' ');
        const xc = +originOffset[0];
        const yc = +originOffset[1];
        const m1 = [1, 0, 0, 0, 1, 0, xc, yc, 1];
        const m2 = [1 / this.scale, 0, 0, 0, 1 / this.scale, 0, 0, 0, 1];
        const m3 = [1, 0, 0, 0, 1, 0, -xc, -yc, 1];
        let m4 = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        let m5 = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        multiply(m4, m1, m2);
        multiply(m5, m4, m3);
        const r = [0, 0];
        transformMat3(r, [x, y], m5);
        return [...r];
    }
    getScaleOffset_T(x, y) {
        const originOffset = this._transform.transformOrigin
            .replace(/px/g, '')
            .split(' ');
        const xc = +originOffset[0];
        const yc = +originOffset[1];
        const m1 = [1, 0, 0, 0, 1, 0, xc, yc, 1];
        const m2 = [1 * this.scale, 0, 0, 0, 1 * this.scale, 0, 0, 0, 1];
        const m3 = [1, 0, 0, 0, 1, 0, -xc, -yc, 1];
        let m4 = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        let m5 = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        multiply(m4, m1, m2);
        multiply(m5, m4, m3);
        const r = [0, 0];
        transformMat3(r, [x, y], m5);
        return [...r];
    }
    isLineBegin() {
        return this.currentEventType === EditorEventType.LineBegin;
    }
    handleConnectPointClick(info) {
        this.currentTarget = info.node;
        if (!this.isLineBegin()) {
            this.currentEventType = EditorEventType.LineBegin;
            this.beginNode = info.node;
            this.beginType = BeginType.NODE;
            const t = new Line(new Point(info.pos[0], info.pos[1]), new Point(info.pos[0], info.pos[1]));
            t.beginNodeConnectType = info.isPre
                ? NodeConnectType.PRE
                : NodeConnectType.NEXT;
            this.currentLine = t;
            this.addLine(t);
        }
        else {
            if (this.beginType === BeginType.PROCESS) {
                this.currentEventType = EditorEventType.LineEnd;
                this.currentLine.update(this.currentLine._begin, new Point(info.pos[0], info.pos[1]));
                this.currentLine.beginNode = this.beginNode;
                this.lineGraph.push(this.currentLine);
                this.beginParam.connect(this.currentLine, info.node, 'begin');
                info.line = this.currentLine;
                info.node.connect(info, ConnectPosition$1.END);
                this.resetAfterAttachLine();
                return;
            }
            if (this.beginType !== BeginType.NODE)
                return;
            const endPointConnectType = info.isPre
                ? NodeConnectType.PRE
                : NodeConnectType.NEXT;
            if (this.currentLine.beginNodeConnectType === endPointConnectType)
                return;
            this.currentEventType = EditorEventType.LineEnd;
            this.currentLine.endNodeConnectType = endPointConnectType;
            this.currentLine.update(this.currentLine._begin, new Point(info.pos[0], info.pos[1]));
            this.lineGraph.push(this.currentLine);
            info.node = this.beginNode;
            info.line = this.currentLine;
            this.currentTarget.connect(info, ConnectPosition$1.END);
            info.isPre = !info.isPre;
            info.node = this.currentTarget;
            this.beginNode.connect(info, ConnectPosition$1.BEGIN);
            this.resetAfterAttachLine();
        }
    }
    paramPointClickHandler(info) {
        this.currentTarget = info.node;
        if (this.currentEventType !== EditorEventType.LineBegin) {
            this.currentEventType = EditorEventType.LineBegin;
            this.beginParam = info.param;
            this.beginNode = info.node;
            this.beginType = BeginType.PARAM;
            const t = new Line(new Point(info.pos[0], info.pos[1]), new Point(info.pos[0], info.pos[1]), { color: info.param.point.color });
            t.beginNodeConnectType = info.param.isInput
                ? NodeConnectType.PRE
                : NodeConnectType.NEXT;
            this.currentLine = t;
            this.addLine(t);
        }
        else {
            if (this.beginType !== BeginType.PARAM)
                return;
            if (info.param.type !== this.beginParam.type) {
                return;
            }
            if (info.param.isConnected)
                return;
            this.currentEventType = EditorEventType.LineEnd;
            this.currentLine.update(this.currentLine._begin, new Point(info.pos[0], info.pos[1]));
            this.lineGraph.push(this.currentLine);
            this.beginParam.connect(this.currentLine, info.param, 'begin');
            info.param.connect(this.currentLine, this.beginParam, 'end');
            this.resetAfterAttachLine();
        }
    }
    processPointClickHandler(info) {
        this.currentTarget = info.node;
        if (this.currentEventType !== EditorEventType.LineBegin) {
            this.currentEventType = EditorEventType.LineBegin;
            this.beginParam = info.param;
            this.beginNode = info.node;
            this.beginType = BeginType.PROCESS;
            const t = new Line(new Point(info.pos[0], info.pos[1]), new Point(info.pos[0], info.pos[1]), { color: 'white' });
            t.beginNodeConnectType = NodeConnectType.NEXT;
            this.currentLine = t;
            this.addLine(t);
        }
        else {
            if (info.param.isConnected)
                return;
            this.currentEventType = EditorEventType.LineEnd;
            this.currentLine.update(this.currentLine._begin, new Point(info.pos[0], info.pos[1]));
            this.currentLine.endNode = info.param.parent;
            this.lineGraph.push(this.currentLine);
            info.line = this.currentLine;
            info.isPre = true;
            this.beginNode.connect(info, ConnectPosition$1.BEGIN);
            info.param.connect(this.currentLine, this.beginNode, 'end');
            this.resetAfterAttachLine();
        }
    }
    resetAfterAttachLine() {
        this.beginNode = null;
        this.beginParam = null;
        this.beginType = null;
        this.currentLine = null;
        this.currentEventType = EditorEventType.Normal;
    }
    SelectHandler(x, y, width, height) {
        this.graph.forEach((item, index) => {
            const [tx, ty] = this.getScaleOffset_T(item.x, item.y);
            const isT = intersection_rectangle(x, y, width, height, tx + this._translateLast[0], ty + this._translateLast[1], item.width * this.scale, item.height * this.scale);
            if (isT) {
                item.selected = true;
            }
            else {
                item.selected = false;
            }
        });
    }
    reviseClientX(input) {
        return input - this.left;
    }
    reviseClientY(input) {
        return input - this.top;
    }
    save() {
        const t = [];
        this.graph.forEach((node) => {
            t.push(node.serialize());
        });
        return t;
    }
    restore(data) { }
    clear() {
        this.container.innerHTML = '';
        this.graph = [];
        this.lineGraph = [];
    }
}

class Label {
    constructor(options) {
        this._text = '';
        this.instance = createSpan();
        this.instance.setAttribute('class', 'wb-param-label');
        if (options.text) {
            this.text = options.text;
        }
        else {
            this.text = '未命名';
        }
    }
    get text() {
        return this._text;
    }
    set text(value) {
        this._text = value;
        this.instance.innerText = value;
    }
}

const getColor = (type) => {
    let color;
    switch (type) {
        case 'string':
            color = '#f703cf';
            break;
        case 'boolean':
            color = '#8e020b';
            break;
        case 'object':
            color = '#20a5e8';
            break;
        case 'number':
            color = '#a4fa60';
            break;
        case 'process':
            color = 'white';
            break;
        case 'any':
            color = '#eeeeee';
            break;
    }
    return color;
};
class ParamPoint {
    constructor(options) {
        this.uid = uuid();
        this.type = options.type;
        this.init();
    }
    init() {
        const svg = createSvg('svg');
        svg.setAttribute('class', 'wb-inputPoint-' + this.type);
        const color = getColor(this.type);
        this.color = color;
        if (this.type === 'process') {
            const polygon = createSvg('polygon');
            polygon.setAttribute('points', '0,0 10,5 0,10');
            polygon.setAttribute('stroke-width', '1px');
            polygon.setAttribute('stroke', 'white');
            polygon.setAttribute('fill', 'none');
            this.inside = polygon;
            svg.appendChild(polygon);
        }
        else {
            const circle = createSvg('circle');
            circle.setAttribute('cx', '5');
            circle.setAttribute('cy', '5');
            circle.setAttribute('r', '4');
            circle.setAttribute('stroke-width', '1px');
            circle.setAttribute('fill', 'none');
            circle.setAttribute('stroke', color);
            this.inside = circle;
            svg.appendChild(circle);
        }
        this.instance = svg;
    }
    update() { }
    connect() {
        this.inside.setAttribute('fill', this.color);
    }
    disConnect() {
        this.inside.setAttribute('fill', 'none');
    }
}

class Input {
    constructor(options) {
        this.type = options.type;
        this.create();
    }
    create() {
        const box = createDiv();
        box.setAttribute('class', 'wb-input-box');
        let inputBox;
        switch (this.type) {
            case 'number':
                inputBox = createInputNumberBox();
                inputBox.setAttribute('class', 'wb-input-number');
                break;
            case 'string':
                inputBox = createInputTextBox();
                inputBox.setAttribute('class', 'wb-input-string');
                break;
            case 'boolean':
                inputBox = createCheckBox();
                inputBox.setAttribute('class', 'wb-input-checkbox');
                break;
            default:
                inputBox = createDiv();
        }
        inputBox.oninput = this.inputChangeHanlde.bind(this);
        box.appendChild(inputBox);
        this.inputIntance = inputBox;
        this.instance = box;
    }
    inputChangeHanlde(v) {
        this.value = this.inputIntance.value;
        this.parent.update(this.value);
    }
    get value() {
        return this._value;
    }
    set value(s) {
        this._value = s;
    }
    hidden() {
        this.instance.style.display = 'none';
    }
    show() {
        this.instance.style.display = '';
    }
}

class Param {
    get value() {
        if (this.isConnected && this.isInput) {
            return this.linkedParam.value;
        }
        return this._value;
    }
    set value(value) {
        this._value = value;
    }
    constructor(options) {
        this.classType = ClassType.PARAM;
        this.uid = uuid();
        this.type = '';
        this.name = '';
        this._value = '';
        this.isConnected = false;
        this.linkedObjects = [];
        this.type = options.type;
        this.isInput = options.isInput !== undefined ? options.isInput : true;
        this.name = options.name !== undefined ? options.name : 'unknown';
        this.value = options.value !== undefined ? options.value : '';
        this.create();
    }
    create() {
        this.instance = createDiv();
        this.instance.setAttribute('class', 'wb-param-base');
        this.point = new ParamPoint({ type: this.type });
        this.label = new Label({ text: this.name });
        this.input = new Input({ type: this.type });
        this.input.parent = this;
        if (this.isInput) {
            this.add(this.point);
            this.add(this.label);
            this.add(this.input);
        }
        else {
            this.add(this.label);
            this.add(this.point);
        }
    }
    add(ele) {
        this.instance.appendChild(ele.instance);
    }
    connect(line, wpElement, position) {
        if (wpElement.classType === ClassType.NODE) {
            const node = wpElement;
            this.point.connect();
            this.isConnected = true;
            this.linkedObjects.push({
                line,
                node,
                id: node.nodeId,
                classType: ClassType.NODE,
            });
            if (position === 'begin') {
                this.isBeign = true;
            }
            else {
                this.isBeign = false;
            }
        }
        if (wpElement.classType === ClassType.PARAM) {
            const param = wpElement;
            if (this.isInput && this.isConnected)
                return;
            this.point.connect();
            this.isConnected = true;
            this.input.hidden();
            if (!this.isInput) {
                this.linkedObjects.push({
                    line,
                    param,
                    id: param.uid,
                    classType: ClassType.PARAM,
                });
            }
            else {
                this.linkedLine = line;
                this.linkedParam = param;
            }
            if (position === 'begin') {
                this.isBeign = true;
            }
            else {
                this.isBeign = false;
            }
            if (this.isInput) {
                this.update(param.value);
            }
        }
    }
    disConnect(paramId) {
        if (this.isInput) {
            this.value = '';
            this.isConnected = false;
            this.input.show();
            this.point.disConnect();
            this.linkedLine.destory();
            this.linkedParam.disConnect(this.uid);
            this.linkedParam = null;
            this.linkedLine = null;
        }
        else {
            const index = this.linkedObjects.findIndex((item) => item.param.uid === paramId);
            if (index === -1)
                return;
            this.linkedObjects[index].line.destory();
            this.linkedObjects.splice(index, 1);
            if (this.linkedObjects.length === 0) {
                this.isConnected = false;
                this.point.disConnect();
            }
        }
    }
    update(value) {
        this.value = value;
    }
}

var ConnectPosition;
(function (ConnectPosition) {
    ConnectPosition["BEGIN"] = "begin";
    ConnectPosition["END"] = "END";
})(ConnectPosition || (ConnectPosition = {}));
class Node extends BaseNode {
    constructor(params) {
        super();
        this.headerClass = 'wb-container-base-header';
        this.active = false;
        this._selected = false;
        this.nodeName = params.nodeName;
        if (params.headerClass) {
            this.headerClass = params.headerClass;
        }
        if (params.color) {
            this.color = params.color;
        }
        this.func = params.func;
        this.initContainer();
        this.initHeader();
        this.instance.appendChild(this.header);
        this.initBody();
        this.instance.appendChild(this.body);
        if (params.preNodeRequired || params.preNodeRequired === undefined) {
            this.preNodeRequired = true;
        }
        else {
            this.preNodeRequired = false;
        }
        if (params.nextNodeRequired || params.nextNodeRequired === undefined) {
            this.nextNodeRequired = true;
        }
        else {
            this.nextNodeRequired = false;
        }
        if (this.nextNodeRequired || this.preNodeRequired) {
            this.initPrePoint(this.preNodeRequired);
            this.leftBody.appendChild(this.prePoint);
            this.initNextPoint(this.nextNodeRequired);
            this.rightBody.appendChild(this.nextPoint);
        }
        if (!this.nextNodeRequired && !this.preNodeRequired) {
            this.yAxisPak = 0;
        }
        if (params.input && params.input.length > 0) {
            params.input.forEach((item, index) => {
                this.addInput(this.initInput(item, index));
            });
        }
        if (params.output && params.output.length > 0) {
            params.output.forEach((item, index) => {
                this.addOutput(this.initOutput(item, index));
            });
        }
        this.x = params.x || 0;
        this.y = params.y || 0;
        if (params.nodeLabel) {
            this.initLabel(params.nodeLabel);
        }
    }
    get x() {
        return this._x;
    }
    set x(value) {
        this._x = value;
        this.instance.style.left = `${this._x}px`;
    }
    get y() {
        return this._y;
    }
    set y(value) {
        this._y = value;
        this.instance.style.top = `${this._y}px`;
    }
    get position() {
        return {
            x: this._x,
            y: this._y,
        };
    }
    get width() {
        return this.instance.clientWidth;
    }
    get height() {
        return this.instance.clientHeight;
    }
    get selected() {
        return this._selected;
    }
    set selected(value) {
        if (this._selected === value) {
            return;
        }
        this._selected = value;
        if (value) {
            this.instance.className = this.instance.className + ' ' + 'selected';
        }
        else {
            this.instance.className = this.instance.className.replace(' selected', '');
        }
    }
    set position(pos) {
        this.x = pos.x;
        this.y = pos.y;
        this.updateRelativeLines(pos.x, pos.y);
    }
    get nodeLabel() {
        return this._nodeLabel;
    }
    set nodeLabel(label) {
        this._nodeLabel = label;
    }
    initContainer() {
        const div = createDiv();
        div.className = 'wb-container-base';
        this.instance = div;
        this.instance.addEventListener('mousedown', () => {
            IO.emit('NodeActive', this);
        });
        this.instance.addEventListener('mouseup', () => {
            IO.emit('NodeInactive', this);
        });
    }
    initHeader() {
        const div = createDiv();
        div.className = this.headerClass;
        div.innerText = this.nodeName;
        if (this.color) {
            div.style.background = this.color;
        }
        this.header = div;
    }
    initBody() {
        const div = createDiv();
        div.className = 'wb-container-base-body';
        const left = createDiv();
        left.className = 'wb-container-base-body-left';
        const right = createDiv();
        right.className = 'wb-container-base-body-right';
        div.appendChild(left);
        div.appendChild(right);
        this.leftBody = left;
        this.rightBody = right;
        this.body = div;
    }
    initPrePoint(ifNeed) {
        const svg = createSvg('svg');
        svg.setAttribute('class', 'wb-prePoint');
        if (!ifNeed) {
            this.prePoint = svg;
            return;
        }
        const polygon = createSvg('polygon');
        polygon.setAttribute('points', '0,0 0,10 5,10 9,5 5,0');
        polygon.setAttribute('stroke-width', '2px');
        polygon.setAttribute('stroke', 'white');
        polygon.setAttribute('fill', 'none');
        svg.appendChild(polygon);
        svg.addEventListener('mousedown', (ev) => {
            ev.stopPropagation();
        });
        svg.addEventListener('mouseup', (ev) => {
            ev.stopPropagation();
        });
        svg.addEventListener('click', (ev) => {
            ev.stopPropagation();
            const info = {
                pos: this.getPrePointPosition(),
                node: this,
                isPre: true,
            };
            if (ev.button === 0) {
                IO.emit('ConnectPointClick', info);
                return;
            }
            if (ev.button === 2) {
                IO.emit('ConnectPointRightClick', info);
            }
        });
        svg.addEventListener('mouseenter', () => {
            IO.emit('ConnectPointEnter', {
                node: this,
                isPre: true,
            });
        });
        svg.addEventListener('mouseleave', () => {
            IO.emit('ConnectPointLeave', {
                node: this,
                isPre: true,
            });
        });
        this.prePoint = svg;
    }
    initNextPoint(ifNeed) {
        const svg = createSvg('svg');
        svg.setAttribute('class', 'wb-nextPoint');
        if (!ifNeed) {
            this.nextPoint = svg;
            return;
        }
        const polygon = createSvg('polygon');
        polygon.setAttribute('points', '0,0 0,10 5,10 9,5 5,0');
        polygon.setAttribute('stroke-width', '2px');
        polygon.setAttribute('stroke', 'white');
        polygon.setAttribute('fill', 'none');
        svg.appendChild(polygon);
        svg.addEventListener('mousedown', (ev) => {
            ev.stopPropagation();
        });
        svg.addEventListener('mouseup', (ev) => {
            ev.stopPropagation();
        });
        svg.addEventListener('click', (ev) => {
            ev.stopPropagation();
            IO.emit('ConnectPointClick', {
                pos: this.getNextPointPosition(),
                node: this,
                isPre: false,
            });
        });
        this.nextPoint = svg;
    }
    initInput({ type, value, name }, index) {
        const box = new Param({ type, value, name });
        box.instance.addEventListener('mousedown', (ev) => {
            ev.stopPropagation();
        });
        box.instance.addEventListener('mouseup', (ev) => {
            ev.stopPropagation();
        });
        box.point.instance.addEventListener('click', (ev) => {
            IO.emit('ParamPointClick', {
                pos: this.getParamPosition(index),
                node: this,
                param: box,
            });
        });
        return box;
    }
    addInput(param) {
        this.inputPoints.push(param);
        param.parent = this;
        this.leftBody.appendChild(param.instance);
    }
    initOutput({ type, value, name }, index) {
        const box = new Param({ type, value, name, isInput: false });
        box.instance.addEventListener('mousedown', (ev) => {
            ev.cancelBubble = true;
        });
        box.instance.addEventListener('mouseup', (ev) => {
            ev.cancelBubble = true;
        });
        box.point.instance.addEventListener('click', (ev) => {
            if (box.type !== 'process') {
                IO.emit('ParamPointClick', {
                    pos: this.getParamPosition(index, false),
                    node: this,
                    param: box,
                });
            }
            else {
                IO.emit('ProcessPointClick', {
                    pos: this.getParamPosition(index, false),
                    node: this,
                    param: box,
                });
            }
        });
        return box;
    }
    addOutput(param) {
        this.outPutPoints.push(param);
        param.parent = this;
        this.rightBody.appendChild(param.instance);
    }
    initLabel(labelText) {
        const label = createSpan();
        label.setAttribute('class', 'wb-container-base-header-label');
        label.innerText = labelText;
        this.header.append(label);
    }
    connect(info, position) {
        if (info.isPre) {
            this.preNodes.push(info.node);
            const inside = this.prePoint.childNodes[0];
            inside.setAttribute('fill', 'white');
            this.preLines.push(info.line);
        }
        else {
            this.nextNodes.push(info.node);
            const inside = this.nextPoint.childNodes[0];
            inside.setAttribute('fill', 'white');
            this.nextLines.push(info.line);
        }
        if (position === ConnectPosition.BEGIN) {
            info.line.beginNode = this;
        }
        else {
            info.line.endNode = this;
        }
    }
    updateRelativeLines(x, y) {
        this.preLines.forEach((line) => {
            var _a;
            const [ix, iy] = this.getPrePointPosition();
            if (((_a = line.beginNode) === null || _a === void 0 ? void 0 : _a.nodeId) === this.nodeId) {
                line.update(new Point(ix, iy), line._end);
            }
            else {
                line.update(line._begin, new Point(ix, iy));
            }
        });
        this.nextLines.forEach((line) => {
            var _a;
            const [ix, iy] = this.getNextPointPosition();
            if (((_a = line.beginNode) === null || _a === void 0 ? void 0 : _a.nodeId) === this.nodeId) {
                line.update(new Point(ix, iy), line._end);
            }
            else {
                line.update(line._begin, new Point(ix, iy));
            }
        });
        this.inputPoints.forEach((param, index) => {
            if (!param.linkedLine)
                return;
            const [ix, iy] = this.getParamPosition(index, true);
            if (param.isBeign) {
                param.linkedLine.update(new Point(ix, iy), param.linkedLine._end);
            }
            else {
                param.linkedLine.update(param.linkedLine._begin, new Point(ix, iy));
            }
        });
        this.outPutPoints.forEach((param, index) => {
            if (!param.linkedObjects)
                return;
            const [ix, iy] = this.getParamPosition(index, false);
            if (param.isBeign) {
                param.linkedObjects.forEach((item) => {
                    item.line.update(new Point(ix, iy), item.line._end);
                });
            }
            else {
                param.linkedObjects.forEach((item) => {
                    item.line.update(item.line._begin, new Point(ix, iy));
                });
            }
        });
    }
    disConnect(id, isPre) {
        let relativeNode;
        if (isPre) {
            const index = this.preNodes.findIndex((item) => item.nodeId === id);
            if (index === -1)
                return;
            relativeNode = this.preNodes[index];
            this.preNodes.splice(index, 1);
            const lineIndex = this.preLines.findIndex((item) => {
                return item.beginNode.nodeId === id || item.endNode.nodeId === id;
            });
            if (lineIndex === -1)
                return;
            IO.emit('LineRemove', this.preLines[lineIndex].id);
            this.preLines.splice(lineIndex, 1);
        }
        else {
            const index = this.nextNodes.findIndex((item) => item.nodeId === id);
            if (index === -1)
                return;
            relativeNode = this.nextNodes[index];
            this.nextNodes.splice(index, 1);
            const lineIndex = this.nextLines.findIndex((item) => {
                return item.beginNode.nodeId === id || item.endNode.nodeId === id;
            });
            if (lineIndex === -1)
                return;
            IO.emit('LineRemove', this.nextLines[lineIndex].id);
            this.nextLines.splice(lineIndex, 1);
        }
        this.callRelativeNodeDisconnect(relativeNode, !isPre);
        this.updatePreOrNextConnectedStatus();
    }
    callRelativeNodeDisconnect(node, isPre) {
        node.disConnect(this.nodeId, isPre);
        node.updatePreOrNextConnectedStatus();
    }
    updatePreOrNextConnectedStatus() {
        const child1 = this.prePoint.childNodes[0];
        const child2 = this.nextPoint.childNodes[0];
        if (this.preLines.length === 0) {
            child1.setAttribute('fill', 'none');
        }
        else {
            child1.setAttribute('fill', 'white');
        }
        if (this.nextLines.length === 0) {
            child2.setAttribute('fill', 'none');
        }
        else {
            child2.setAttribute('fill', 'white');
        }
    }
    serialize() {
        const container = {
            nodeId: this.nodeId,
            nodeName: this.nodeName,
            nodeType: this.nodeType,
            x: this.x,
            y: this.y,
        };
        container.preNodeIds = this.preNodes.map((node) => node.nodeId);
        container.nextNodeIds = this.nextNodes.map((node) => node.nodeId);
        container.inputParamsIds = this.inputPoints.map((param) => {
            var _a;
            return (_a = param.linkedParam) === null || _a === void 0 ? void 0 : _a.uid;
        });
        container.outputParamsIds = this.outPutPoints.map((param) => {
            const ar = [];
            param.linkedObjects.forEach((item) => {
                ar.push(item.param.uid);
            });
            return ar;
        });
        return JSON.stringify(container);
    }
}

const ColorPreset = {
    PurpleGradient: 'linear-gradient(135deg,#622774,rgba(0,0,0,0.5))',
    BrownGradient: 'linear-gradient(135deg,#c0392b,rgba(0,0,0,0.5))',
    PinkGradient: 'linear-gradient(135deg,#f54ea2,rgba(0,0,0,0.5))',
    GreenGradient: 'linear-gradient(135deg,#1abc9c,rgba(0,0,0,0.5))',
    BlueGradient: 'linear-gradient(135deg,#1e90ff,rgba(0,0,0,0.5))',
};

class NodeFactory {
    GetNode(x, y, nodeLabel, type, value) {
        return new Node({
            x,
            y,
            nodeName: 'Get',
            nodeLabel,
            preNodeRequired: false,
            nextNodeRequired: false,
            color: ColorPreset.PurpleGradient,
            output: [
                {
                    name: 'out',
                    type,
                    value,
                },
            ],
            func: () => { },
        });
    }
    BeginNode(x, y) {
        return new Node({
            x,
            y,
            nodeName: 'Begin',
            nodeLabel: '',
            preNodeRequired: false,
            nextNodeRequired: true,
            color: ColorPreset.BrownGradient,
            func: () => { },
        });
    }
    plusNumber() {
        return new Node({
            x: 0,
            y: 0,
            nodeName: 'Plus',
            color: ColorPreset.BlueGradient,
            input: [
                {
                    type: 'number',
                    name: 'in1',
                    value: 0,
                },
                {
                    type: 'number',
                    name: 'in2',
                    value: 0,
                },
            ],
            output: [
                {
                    type: 'number',
                    name: 'out',
                },
            ],
            func: (inputs, outputs) => {
                outputs[0].value = Number(inputs[0].value) + Number(inputs[1].value);
            },
        });
    }
    minusNumber() {
        return new Node({
            x: 0,
            y: 0,
            nodeName: 'Minus',
            color: ColorPreset.BlueGradient,
            input: [
                {
                    type: 'number',
                    name: 'in1',
                    value: 0,
                },
                {
                    type: 'number',
                    name: 'in2',
                    value: 0,
                },
            ],
            output: [
                {
                    type: 'number',
                    name: 'out',
                },
            ],
            func: (inputs, outputs) => {
                outputs[0].value = Number(inputs[0].value) - Number(inputs[1].value);
            },
        });
    }
    multiNumber() {
        return new Node({
            x: 0,
            y: 0,
            nodeName: 'Multi',
            color: ColorPreset.BlueGradient,
            input: [
                {
                    type: 'number',
                    name: 'in1',
                    value: 0,
                },
                {
                    type: 'number',
                    name: 'in2',
                    value: 0,
                },
            ],
            output: [
                {
                    type: 'number',
                    name: 'out',
                },
            ],
            func: (inputs, outputs) => {
                outputs[0].value = Number(inputs[0].value) * Number(inputs[1].value);
            },
        });
    }
    diviNumber() {
        return new Node({
            x: 0,
            y: 0,
            nodeName: 'Division',
            color: ColorPreset.BlueGradient,
            input: [
                {
                    type: 'number',
                    name: 'in1',
                    value: 0,
                },
                {
                    type: 'number',
                    name: 'in2',
                    value: 0,
                },
            ],
            output: [
                {
                    type: 'number',
                    name: 'out',
                },
            ],
            func: (inputs, outputs) => {
                outputs[0].value = Number(inputs[0].value) / Number(inputs[1].value);
            },
        });
    }
}

export { BaseNode, BeginType, BluePrintEditor, ConnectPosition$1 as ConnectPosition, EditorEventType, Line, MouseDownType, Node$1 as Node, NodeFactory, Point };
