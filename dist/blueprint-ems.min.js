const map = '123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function uuid() {
    let ranStr = '';
    for (let i = 0; i < 19; i++) {
        ranStr += map[Math.floor(Math.random() * (48 + 9))];
    }
    return ranStr + new Date().getTime();
}

class BaseNode {
    constructor() {
        this.inputPoints = [];
        this.outPutPoints = [];
        this.variables = {};
        this.nodeName = 'Function Name';
        this.nodeType = 'Function';
        this.nodeId = uuid();
        this.async = false;
        this._x = 0;
        this._y = 0;
        this.preNodes = [];
        this.nextNodes = [];
        this.preLines = [];
        this.nextLines = [];
    }
    execute() {
        this.func(this.inputPoints);
        this.nextNodes.forEach((item) => {
            item.execute();
        });
    }
    getPrePointPosition() {
        return [this._x + 10, this._y + 32 + 10 + 5];
    }
    getNextPointPosition() {
        return [this._x + 200 - 10, this._y + 32 + 10 + 5];
    }
    getParamPosition(index, isInput = true) {
        if (isInput) {
            return [this._x + 10, this._y + 32 + 25 + 20 * index + 10];
        }
        else {
            return [this._x + 200, this._y + 32 + 25 + 20 * index + 10];
        }
    }
}

class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    middileWith(p) {
        const mx = (this.x + p.x) / 2;
        const my = (this.y + p.y) / 2;
        return new Point(mx, my);
    }
    distanceWith(p) {
        return Math.pow((p.x - this.x) * (p.x - this.x) + (p.y - this.y) * (p.y - this.y), 0.5);
    }
}

class IO {
    constructor() { }
    static on(eventName, listener, options = {}) {
        if (eventName === undefined || listener === undefined) {
            console.error('event or listener is required!');
            return;
        }
        if (!(eventName in this._events)) {
            this._events[eventName] = [];
        }
        if (this._events[eventName].length >= this.MAX_LISTENERS) {
            console.error(`${eventName}'s number of listeners has reached the limit`);
            return;
        }
        if (options.only) {
            if (this._events[eventName].length !== 0) {
                return;
            }
        }
        this._events[eventName].push({
            handler: listener,
            once: options.once != undefined ? options.once : false,
        });
    }
    static emit(eventName, ...args) {
        if (!(eventName in this._events)) {
            return false;
        }
        const listeners = this._events[eventName];
        try {
            listeners.forEach((eventTarget) => {
                eventTarget.handler(...args);
                if (eventTarget.once) {
                    this.removeListener(eventName, eventTarget.handler);
                }
            });
        }
        catch (error) {
            console.error(error);
        }
    }
    static once(eventName, listener) {
        this.on(eventName, listener, { once: true });
    }
    static off(eventName, listener) {
        this.removeListener(eventName, listener);
    }
    static removeListener(eventName, listener) {
        if (!(eventName in this._events)) {
            console.warn(`there is no event named ${eventName}`);
            return false;
        }
        let listenerIndex = null;
        for (let i = 0, l = this._events[eventName].length; i < l; i++) {
            if (this._events[eventName][i].handler === listener) {
                listenerIndex = i;
                break;
            }
        }
        if (listenerIndex !== null) {
            this._events[eventName].splice(listenerIndex, 1);
        }
    }
    static removeAllListener(eventName) {
        if (this._events[eventName] === undefined) {
            console.warn(`there is no event named ${eventName}`);
            return false;
        }
        this._events[eventName] = [];
    }
    static setMaxListeners(num) {
        this.MAX_LISTENERS = num;
    }
    static clear() {
        this._events = Object.create(null);
    }
}
IO._events = Object.create(null);
IO.MAX_LISTENERS = 30;

const createDom = (tag) => {
    return document.createElement(tag);
};
const createDiv = () => {
    return createDom('div');
};
const createSvg = (tag) => {
    return document.createElementNS('http://www.w3.org/2000/svg', tag);
};
const createInputNumberBox = () => {
    const input = document.createElement('input');
    input.setAttribute('type', 'number');
    return input;
};
const createInputTextBox = () => {
    const input = document.createElement('input');
    input.setAttribute('type', 'text');
    return input;
};
const createSpan = () => {
    return createDom('span');
};
const createCheckBox = () => {
    const input = document.createElement('input');
    input.setAttribute('type', 'checkbox');
    return input;
};

/**
 * Common utilities
 * @module glMatrix
 */
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new ARRAY_TYPE(2);

  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

(function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
})();

class Selector {
    constructor() {
        this.isHidden = true;
        this.create();
    }
    create() {
        const container = createSvg('svg');
        container.style.position = 'absolute';
        container.style.opacity = '0.5';
        const rec = createSvg('rect');
        rec.setAttribute('width', '0');
        rec.setAttribute('height', '0');
        rec.setAttribute('stroke', '#5352ed');
        rec.setAttribute('stroke-width', '4px');
        rec.setAttribute('fill', '#70a1ff');
        this.inside = rec;
        container.appendChild(rec);
        this.instance = container;
        document.body.appendChild(container);
    }
    update(x, y, width, height) {
        if (width >= 0 && height >= 0) {
            this.instance.style.left = x + 'px';
            this.instance.style.top = y + 'px';
            this.x = x;
            this.y = y;
        }
        if (width < 0 && height < 0) {
            this.instance.style.left = x + width + 'px';
            this.instance.style.top = y + height + 'px';
            this.x = x + width;
            this.y = y + height;
        }
        if (width > 0 && height < 0) {
            this.instance.style.left = x + 'px';
            this.instance.style.top = y + height + 'px';
            this.x = x;
            this.y = y + height;
        }
        if (width < 0 && height > 0) {
            this.instance.style.left = x + width + 'px';
            this.instance.style.top = y + 'px';
            this.x = x + width;
            this.y = y;
        }
        this.instance.style.width = Math.abs(width) + 'px';
        this.instance.style.height = Math.abs(height) + 'px';
        this.width = Math.abs(width);
        this.height = Math.abs(height);
        this.inside.setAttribute('width', `${Math.abs(width)}`);
        this.inside.setAttribute('height', `${Math.abs(height)}`);
    }
    show() {
        this.instance.style.display = 'block';
        this.isHidden = false;
    }
    hidden() {
        this.update(0, 0, 0, 0);
        this.instance.style.display = 'none';
        this.isHidden = true;
    }
}

var Os;
(function (Os) {
    Os["Windows"] = "Windows";
    Os["Mac"] = "Mac";
    Os["Linux"] = "Linux";
})(Os || (Os = {}));

const intersection_rectangle = (x, y, width, height, x2, y2, width2, height2) => {
    const centerX = x + width / 2;
    const centerY = y + height / 2;
    const centerX2 = x2 + width2 / 2;
    const centerY2 = y2 + height2 / 2;
    const x_axis_projection = Math.abs(centerX2 - centerX);
    const y_axis_projection = Math.abs(centerY2 - centerY);
    if ((width + width2) / 2 > x_axis_projection &&
        (height + height2) / 2 > y_axis_projection) {
        return true;
    }
    return false;
};

var MouseDownType;
(function (MouseDownType) {
    MouseDownType[MouseDownType["LEFT"] = 0] = "LEFT";
    MouseDownType[MouseDownType["RIGHT"] = 2] = "RIGHT";
    MouseDownType[MouseDownType["NONE"] = -1] = "NONE";
})(MouseDownType || (MouseDownType = {}));
var EditorEventType;
(function (EditorEventType) {
    EditorEventType["Normal"] = "normal";
    EditorEventType["NodeActive"] = "NodeActive";
    EditorEventType["LineBegin"] = "LineBegin";
    EditorEventType["LineEnd"] = "LineEnd";
})(EditorEventType || (EditorEventType = {}));
class BluePrintEditor {
    constructor(container) {
        this.graph = [];
        this.lineGraph = [];
        this.scale = 1;
        this._orginSize = [];
        this._mouseDownType = -1;
        this._mouseDownPosition = [];
        this._translateLast = [0, 0];
        this._transform = {
            translate: [0, 0],
            transformOrigin: '0px 0px',
        };
        this.currentEventType = EditorEventType.Normal;
        IO.emit('beforeCreated');
        IO.on('NodeActive', (node) => {
            if (this.currentEventType === EditorEventType.LineBegin)
                return;
            this.NodeActiveHandler(node);
        }, { only: true });
        IO.on('NodeInactive', () => {
            if (this.currentEventType !== EditorEventType.LineBegin) {
                this.currentEventType = EditorEventType.Normal;
            }
            this.currentTarget = null;
        }, { only: true });
        IO.on('ConnectPointClick', (info) => {
            this.handleConnectPointClick(info);
        }, { only: true });
        IO.on('ParamPointClick', (info) => {
            this.paramPointClickHandler(info);
        }, { only: true });
        IO.on('ConnectPointEnter', (info) => { }, { only: true });
        container.oncontextmenu = function () {
            return false;
        };
        this.container = container;
        this._orginSize[0] = this.container.getClientRects()[0].width;
        this._orginSize[1] = this.container.getClientRects()[0].height;
        container.style.position = 'relative';
        container.style.transform = 'scale(1)';
        this.initLineContainer();
        this.init();
    }
    init() {
        this.container.addEventListener('mousedown', (ev) => {
            this.setMouseDownType(ev.button);
            this.recordPosition(ev.clientX, ev.clientY);
        });
        document.body.addEventListener('mouseup', (ev) => {
            this._mouseDownType = -1;
            this._transform.translate = [...this._translateLast];
            this._mouseDownPosition = [];
            this.selector.hidden();
            if (this.currentEventType === EditorEventType.LineBegin) {
                this.currentLine.destory();
                this.currentLine = null;
                this.currentEventType = EditorEventType.Normal;
            }
        });
        document.body.addEventListener('mousemove', (ev) => {
            if (this._mouseDownType == MouseDownType.RIGHT) {
                this.translate(ev);
                return;
            }
            if (this._mouseDownType == MouseDownType.LEFT &&
                this.currentEventType == EditorEventType.NodeActive &&
                this._mouseDownPosition[0] != 0) {
                this.NodeMoveHandler(ev);
                return;
            }
            if (this.currentEventType === EditorEventType.LineBegin) {
                const [ox, oy] = this.getScaleOffset(ev.clientX - this._translateLast[0], ev.clientY - this._translateLast[1]);
                this.currentLine.update(this.currentLine._begin, new Point(ox, oy));
                return;
            }
            if (this._mouseDownType === MouseDownType.LEFT &&
                this.currentEventType === EditorEventType.Normal) {
                const ow = ev.clientX - this._mouseDownPosition[0];
                const oh = ev.clientY - this._mouseDownPosition[1];
                if (this.selector.isHidden === true) {
                    this.selector.show();
                }
                this.selector.update(this._mouseDownPosition[0], this._mouseDownPosition[1], ow, oh);
                this.SelectHandler(this.selector.x, this.selector.y, this.selector.width, this.selector.height);
            }
        });
        this.container.addEventListener('mousewheel', (ev) => {
            this.ScaleHandler(ev);
            this.resize(this.scale);
        });
        this.selector = new Selector();
    }
    add(node) {
        this.container.appendChild(node.instance);
        this.graph.push(node);
    }
    addLine(line) {
        this.lineContainer.appendChild(line.instance);
    }
    translate(ev) {
        const goalX = ev.clientX - this._mouseDownPosition[0] + this._transform.translate[0];
        const goalY = ev.clientY - this._mouseDownPosition[1] + this._transform.translate[1];
        this.container.style.transform = `translate(${goalX}px, ${goalY}px) scale(${this.scale})`;
        this._translateLast = [goalX, goalY];
    }
    resize(scale) {
    }
    setMouseDownType(type) {
        if (type === 2) {
            this._mouseDownType = 2;
        }
        else if (type === 0) {
            this._mouseDownType = 0;
        }
    }
    recordPosition(x, y) {
        this._mouseDownPosition[0] = x;
        this._mouseDownPosition[1] = y;
    }
    initLineContainer() {
        const svg = createSvg('svg');
        svg.style.width = this.container.getClientRects()[0].width + 'px';
        svg.style.height = this.container.getClientRects()[0].height + 'px';
        svg.style.left = 0;
        svg.style.top = 0;
        this.lineContainer = svg;
        this.container.appendChild(this.lineContainer);
    }
    PreNodeHandler() { }
    ScaleHandler(ev) {
        if (ev.deltaY < 0) {
            if (this.scale >= 1)
                return;
            this.scale += 0.1;
            this.container.style.transformOrigin = `${ev.x}px ${ev.y}px`;
            this._transform.transformOrigin = `${ev.x}px ${ev.y}px`;
            this.container.style.transform = `translate(${this._transform.translate[0]}px, ${this._transform.translate[1]}px) scale(${this.scale})`;
        }
        else {
            if (this.scale < 0.3)
                return;
            this.scale -= 0.1;
            this.container.style.transformOrigin = `${ev.x}px ${ev.y}px`;
            this._transform.transformOrigin = `${ev.x}px ${ev.y}px`;
            this.container.style.transform = `translate(${this._transform.translate[0]}px, ${this._transform.translate[1]}px) scale(${this.scale})`;
        }
    }
    NodeMoveHandler(ev) {
        this.currentTarget.position = {
            x: ev.clientX - this._mouseDownPosition[0] + this._mouseDownPosition[2],
            y: ev.clientY - this._mouseDownPosition[1] + this._mouseDownPosition[3],
        };
    }
    NodeActiveHandler(node) {
        this.currentEventType = EditorEventType.NodeActive;
        this.currentTarget = node;
        this._mouseDownPosition[0] = 0;
        this._mouseDownPosition[1] = 0;
        this._mouseDownPosition[2] = node.x;
        this._mouseDownPosition[3] = node.y;
    }
    getScaleOffset(x, y) {
        const originOffset = this._transform.transformOrigin
            .replace(/px/g, '')
            .split(' ');
        const xc = +originOffset[0];
        const yc = +originOffset[1];
        const m1 = [1, 0, 0, 0, 1, 0, xc, yc, 1];
        const m2 = [1 / this.scale, 0, 0, 0, 1 / this.scale, 0, 0, 0, 1];
        const m3 = [1, 0, 0, 0, 1, 0, -xc, -yc, 1];
        let m4 = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        let m5 = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        multiply(m4, m1, m2);
        multiply(m5, m4, m3);
        const r = [0, 0];
        transformMat3(r, [x, y], m5);
        return [...r];
    }
    isLineBegin() {
        return this.currentEventType === EditorEventType.LineBegin;
    }
    handleConnectPointClick(info) {
        this.currentTarget = info.node;
        if (!this.isLineBegin()) {
            this.currentEventType = EditorEventType.LineBegin;
            this.beginNode = info.node;
            const t = new Line(new Point(info.pos[0], info.pos[1]), new Point(info.pos[0], info.pos[1]));
            this.currentLine = t;
            this.addLine(t);
        }
        else {
            this.currentEventType = EditorEventType.LineEnd;
            this.currentLine.update(this.currentLine._begin, new Point(info.pos[0], info.pos[1]));
            this.lineGraph.push(this.currentLine);
            info.node = this.beginNode;
            info.line = this.currentLine;
            this.currentTarget.connect(info);
            info.isPre = !info.isPre;
            info.node = this.currentTarget;
            info.node = this.beginNode.connect(info);
            this.resetAfterAttachLine();
        }
    }
    paramPointClickHandler(info) {
        this.currentTarget = info.node;
        if (this.currentEventType !== EditorEventType.LineBegin) {
            this.currentEventType = EditorEventType.LineBegin;
            this.beginParam = info.param;
            this.beginNode = info.node;
            const t = new Line(new Point(info.pos[0], info.pos[1]), new Point(info.pos[0], info.pos[1]), { color: info.param.point.color });
            this.currentLine = t;
            this.addLine(t);
        }
        else {
            if (info.param.type !== this.beginParam.type) {
                return;
            }
            this.currentEventType = EditorEventType.LineEnd;
            this.currentLine.update(this.currentLine._begin, new Point(info.pos[0], info.pos[1]));
            this.lineGraph.push(this.currentLine);
            this.beginParam.connect(this.currentLine, info.param, 'begin');
            info.param.connect(this.currentLine, this.beginParam, 'end');
            this.resetAfterAttachLine();
        }
    }
    resetAfterAttachLine() {
        this.beginNode = null;
        this.beginParam = null;
        this.currentLine = null;
        this.currentEventType = EditorEventType.Normal;
    }
    SelectHandler(x, y, width, height) {
        this.graph.forEach((item) => {
            const isT = intersection_rectangle(x, y, width, height, item.x, item.y, item.width, item.height);
            if (isT) {
                item.selected = true;
            }
            else {
                item.selected = false;
            }
        });
    }
}

class Label {
    constructor(options) {
        this._text = '';
        this.instance = createSpan();
        this.instance.setAttribute('class', 'wb-param-label');
        if (options.text) {
            this.text = options.text;
        }
        else {
            this.text = '未命名';
        }
    }
    get text() {
        return this._text;
    }
    set text(value) {
        this._text = value;
        this.instance.innerText = value;
    }
}

const getColor = (type) => {
    let color;
    switch (type) {
        case 'string':
            color = '#f703cf';
            break;
        case 'boolean':
            color = '#8e020b';
            break;
        case 'object':
            color = '#20a5e8';
            break;
        case 'number':
            color = '#a4fa60';
            break;
    }
    return color;
};
class ParamPoint {
    constructor(options) {
        this.uid = uuid();
        this.type = options.type;
        this.init();
    }
    init() {
        const svg = createSvg('svg');
        svg.setAttribute('class', 'wb-inputPoint-' + this.type);
        const circle = createSvg('circle');
        circle.setAttribute('cx', '5');
        circle.setAttribute('cy', '5');
        circle.setAttribute('r', '4');
        circle.setAttribute('stroke-width', '1px');
        circle.setAttribute('fill', 'none');
        const color = getColor(this.type);
        this.color = color;
        circle.setAttribute('stroke', color);
        this.inside = circle;
        svg.appendChild(circle);
        this.instance = svg;
    }
    update() { }
    connect() {
        this.inside.setAttribute('fill', this.color);
    }
    disConnect() {
        this.inside.setAttribute('fill', 'none');
    }
}

class Input {
    constructor(options) {
        this.type = options.type;
        this.create();
    }
    create() {
        const box = createDiv();
        box.setAttribute('class', 'wb-input-box');
        let inputBox;
        switch (this.type) {
            case 'number':
                inputBox = createInputNumberBox();
                inputBox.setAttribute('class', 'wb-input-number');
                break;
            case 'string':
                inputBox = createInputTextBox();
                inputBox.setAttribute('class', 'wb-input-string');
                break;
            case 'boolean':
                inputBox = createCheckBox();
                inputBox.setAttribute('class', 'wb-input-checkbox');
                break;
            default:
                inputBox = createDiv();
        }
        inputBox.oninput = this.inputChangeHanlde.bind(this);
        box.appendChild(inputBox);
        this.inputIntance = inputBox;
        this.instance = box;
    }
    inputChangeHanlde(v) {
        this.value = this.inputIntance.value;
    }
    get value() {
        return this._value;
    }
    set value(s) {
        this._value = s;
    }
    hidden() {
        this.instance.style.display = 'none';
    }
    show() {
        this.instance.style.display = '';
    }
}

class Param {
    constructor(options) {
        this.uid = uuid();
        this.type = '';
        this.type = options.type;
        this.isInput = options.isInput !== undefined ? options.isInput : true;
        this.create();
    }
    create() {
        this.instance = createDiv();
        this.instance.setAttribute('class', 'wb-param-base');
        this.point = new ParamPoint({ type: this.type });
        this.label = new Label({});
        this.input = new Input({ type: this.type });
        if (this.isInput) {
            this.add(this.point);
            this.add(this.label);
            this.add(this.input);
        }
        else {
            this.add(this.label);
            this.add(this.point);
        }
    }
    add(ele) {
        this.instance.appendChild(ele.instance);
    }
    connect(line, param, position) {
        this.point.connect();
        this.input.hidden();
        this.linkedLine = line;
        this.linkedParam = param;
        if (position === 'begin') {
            this.isBeign = true;
        }
        else {
            this.isBeign = false;
        }
    }
    disConnect() { }
}

class Node extends BaseNode {
    constructor(params) {
        super();
        this.headerClass = 'wb-container-base-header';
        this.active = false;
        this._selected = false;
        this.nodeName = params.nodeName;
        if (params.headerClass) {
            this.headerClass = params.headerClass;
        }
        if (params.color) {
            this.color = params.color;
        }
        this.initContainer();
        this.initHeader();
        this.initBody();
        this.initPrePoint();
        this.initNextPoint();
        this.instance.appendChild(this.header);
        this.instance.appendChild(this.body);
        this.leftBody.appendChild(this.prePoint);
        this.rightBody.appendChild(this.nextPoint);
        if (params.input && params.input.length > 0) {
            params.input.forEach((item, index) => {
                this.addInput(this.initInput(item.type, index));
            });
        }
        if (params.output && params.output.length > 0) {
            params.output.forEach((item, index) => {
                this.addOutput(this.initOutput(item.type, index));
            });
        }
        this.x = params.x || 0;
        this.y = params.y || 0;
    }
    get x() {
        return this._x;
    }
    set x(value) {
        this._x = value;
        this.instance.style.left = `${this._x}px`;
    }
    get y() {
        return this._y;
    }
    set y(value) {
        this._y = value;
        this.instance.style.top = `${this._y}px`;
    }
    get position() {
        return {
            x: this._x,
            y: this._y,
        };
    }
    get width() {
        return this.instance.clientWidth;
    }
    get height() {
        return this.instance.clientHeight;
    }
    get selected() {
        return this._selected;
    }
    set selected(value) {
        if (this._selected === value) {
            return;
        }
        this._selected = value;
        if (value) {
            this.instance.className = this.instance.className + ' ' + 'selected';
        }
        else {
            this.instance.className = this.instance.className.replace(' selected', '');
        }
    }
    initContainer() {
        const div = createDiv();
        div.className = 'wb-container-base';
        this.instance = div;
        this.instance.addEventListener('mousedown', () => {
            IO.emit('NodeActive', this);
        });
        this.instance.addEventListener('mouseup', () => {
            IO.emit('NodeInactive', this);
        });
    }
    initHeader() {
        const div = createDiv();
        div.className = this.headerClass;
        div.innerText = this.nodeName;
        if (this.color) {
            div.style.backgroundColor = this.color;
        }
        this.header = div;
    }
    initBody() {
        const div = createDiv();
        div.className = 'wb-container-base-body';
        const left = createDiv();
        left.className = 'wb-container-base-body-left';
        const right = createDiv();
        right.className = 'wb-container-base-body-right';
        div.appendChild(left);
        div.appendChild(right);
        this.leftBody = left;
        this.rightBody = right;
        this.body = div;
    }
    initPrePoint() {
        const svg = createSvg('svg');
        svg.setAttribute('class', 'wb-prePoint');
        const polygon = createSvg('polygon');
        polygon.setAttribute('points', '0,0 0,10 5,10 9,5 5,0');
        polygon.setAttribute('stroke-width', '2px');
        polygon.setAttribute('stroke', 'white');
        polygon.setAttribute('fill', 'none');
        svg.appendChild(polygon);
        svg.addEventListener('mousedown', (ev) => {
            ev.cancelBubble = true;
        });
        svg.addEventListener('mouseup', (ev) => {
            ev.cancelBubble = true;
        });
        svg.addEventListener('click', (ev) => {
            ev.cancelBubble = true;
            IO.emit('ConnectPointClick', {
                pos: this.getPrePointPosition(),
                node: this,
                isPre: true,
            });
        });
        svg.addEventListener('mouseenter', () => {
            IO.emit('ConnectPointEnter', {
                node: this,
                isPre: true,
            });
        });
        svg.addEventListener('mouseleave', () => {
            IO.emit('ConnectPointLeave', {
                node: this,
                isPre: true,
            });
        });
        this.prePoint = svg;
    }
    initNextPoint() {
        const svg = createSvg('svg');
        svg.setAttribute('class', 'wb-nextPoint');
        const polygon = createSvg('polygon');
        polygon.setAttribute('points', '0,0 0,10 5,10 9,5 5,0');
        polygon.setAttribute('stroke-width', '2px');
        polygon.setAttribute('stroke', 'white');
        polygon.setAttribute('fill', 'none');
        svg.appendChild(polygon);
        svg.addEventListener('mousedown', (ev) => {
            ev.cancelBubble = true;
        });
        svg.addEventListener('mouseup', (ev) => {
            ev.cancelBubble = true;
        });
        svg.addEventListener('click', (ev) => {
            ev.cancelBubble = true;
            IO.emit('ConnectPointClick', {
                pos: this.getNextPointPosition(),
                node: this,
                isPre: false,
            });
        });
        this.nextPoint = svg;
    }
    initInput(type, index) {
        const box = new Param({ type });
        box.instance.addEventListener('mousedown', (ev) => {
            ev.cancelBubble = true;
        });
        box.instance.addEventListener('mouseup', (ev) => {
            ev.cancelBubble = true;
        });
        box.point.instance.addEventListener('click', (ev) => {
            IO.emit('ParamPointClick', {
                pos: this.getParamPosition(index),
                node: this,
                param: box,
            });
        });
        return box;
    }
    addInput(param) {
        this.inputPoints.push(param);
        param.parent = this;
        this.leftBody.appendChild(param.instance);
    }
    initOutput(type, index) {
        const box = new Param({ type, isInput: false });
        box.instance.addEventListener('mousedown', (ev) => {
            ev.cancelBubble = true;
        });
        box.instance.addEventListener('mouseup', (ev) => {
            ev.cancelBubble = true;
        });
        box.point.instance.addEventListener('click', (ev) => {
            IO.emit('ParamPointClick', {
                pos: this.getParamPosition(index, false),
                node: this,
                param: box,
            });
        });
        return box;
    }
    addOutput(param) {
        this.outPutPoints.push(param);
        param.parent = this;
        this.rightBody.appendChild(param.instance);
    }
    set position(pos) {
        this.x = pos.x;
        this.y = pos.y;
        this.updateRelativeLines(pos.x, pos.y);
    }
    connect(info) {
        if (info.isPre) {
            this.preNodes.push(info.node);
            const inside = this.prePoint.childNodes[0];
            inside.setAttribute('fill', 'white');
            this.preLines.push(info.line);
            info.line.endNode = this;
        }
        else {
            this.nextNodes.push(info.node);
            const inside = this.nextPoint.childNodes[0];
            inside.setAttribute('fill', 'white');
            this.nextLines.push(info.line);
            info.line.beginNode = this;
        }
    }
    updateRelativeLines(x, y) {
        const [ix, iy] = this.getPrePointPosition();
        this.preLines.forEach((line) => {
            if (line.beginNode.nodeId === this.nodeId) {
                line.update(new Point(ix, iy), line._end);
            }
            else {
                line.update(line._begin, new Point(ix, iy));
            }
        });
        this.nextLines.forEach((line) => {
            const [ix, iy] = this.getNextPointPosition();
            if (line.beginNode.nodeId === this.nodeId) {
                line.update(new Point(ix, iy), line._end);
            }
            else {
                line.update(line._begin, new Point(ix, iy));
            }
        });
        this.inputPoints.forEach((param, index) => {
            if (!param.linkedLine)
                return;
            const [ix, iy] = this.getParamPosition(index);
            if (param.isBeign) {
                param.linkedLine.update(new Point(ix, iy), param.linkedLine._end);
            }
            else {
                param.linkedLine.update(param.linkedLine._begin, new Point(ix, iy));
            }
        });
        this.outPutPoints.forEach((param, index) => {
            if (!param.linkedLine)
                return;
            const [ix, iy] = this.getParamPosition(index, false);
            if (param.isBeign) {
                param.linkedLine.update(new Point(ix, iy), param.linkedLine._end);
            }
            else {
                param.linkedLine.update(param.linkedLine._begin, new Point(ix, iy));
            }
        });
    }
}

class BaseLine {
    constructor() {
        this._color = 'white';
    }
    _getControlPoint(begin, end) {
        const middlePoint = begin.middileWith(end);
        if (begin.x < end.x) {
            return [middlePoint.x, begin.y, middlePoint.x, end.y];
        }
        else {
            return [
                begin.x + begin.x - middlePoint.x,
                begin.y,
                end.x - (middlePoint.x - end.x),
                end.y,
            ];
        }
    }
    _setSize() {
        this._width = Math.abs(this._end.x - this._begin.x);
        this._height = Math.abs(this._end.y - this._begin.y);
    }
}

class Line extends BaseLine {
    constructor(begin, end, options = {}) {
        super();
        if (options.color)
            this._color = options.color;
        const Path = createSvg('path');
        this.instance = Path;
        Path.setAttribute('stroke-width', '2px');
        Path.setAttribute('stroke', this.color);
        Path.setAttribute('fill', 'none');
        this.update(begin, end);
    }
    get color() {
        return this._color;
    }
    set color(value) {
        this._color = value;
        this.instance.setAttribute('stroke', value);
    }
    update(begin, end) {
        const cp = this._getControlPoint(begin, end);
        this._begin = begin;
        this._end = end;
        this._setSize();
        const path = `M${begin.x},${begin.y} C${cp[0]},${cp[1]} ${cp[2]},${cp[3]} ${end.x},${end.y}`;
        this.instance.setAttribute('d', path);
    }
    destory() {
        this.instance.parentNode.removeChild(this.instance);
    }
}

export { BaseNode, BluePrintEditor, EditorEventType, Line, MouseDownType, Node, Point };
