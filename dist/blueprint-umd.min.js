(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.blueprint = {}));
})(this, (function (exports) { 'use strict';

  const map = '123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
  function uuid() {
      let ranStr = '';
      for (let i = 0; i < 19; i++) {
          ranStr += map[Math.floor(Math.random() * (48 + 9))];
      }
      return ranStr + new Date().getTime();
  }

  class BaseNode {
      constructor() {
          this.inputPoints = [];
          this.outPutPoints = [];
          this.variables = {};
          this.nodeName = 'Function Name';
          this.nodeType = 'Function';
          this.nodeId = uuid();
          this.async = false;
          this._x = 0;
          this._y = 0;
          this.preNode = [];
          this.nextNode = [];
      }
      execute() {
          this.func(this.inputPoints);
          this.nextNode.forEach((item) => {
              item.execute();
          });
      }
  }

  class Point {
      constructor(x, y) {
          this.x = x;
          this.y = y;
      }
      middileWith(p) {
          const mx = (this.x + p.x) / 2;
          const my = (this.y + p.y) / 2;
          return new Point(mx, my);
      }
      distanceWith(p) {
          return Math.pow((p.x - this.x) * (p.x - this.x) + (p.y - this.y) * (p.y - this.y), 0.5);
      }
  }

  class IO {
      constructor() { }
      static on(eventName, listener, options = {}) {
          if (eventName === undefined || listener === undefined) {
              console.error('event or listener is required!');
              return;
          }
          if (!(eventName in this._events)) {
              this._events[eventName] = [];
          }
          if (this._events[eventName].length >= this.MAX_LISTENERS) {
              console.error(`${eventName}'s number of listeners has reached the limit`);
              return;
          }
          this._events[eventName].push({
              handler: listener,
              once: options.once != undefined ? options.once : false,
          });
      }
      static emit(eventName, ...args) {
          if (!(eventName in this._events)) {
              return false;
          }
          const listeners = this._events[eventName];
          try {
              listeners.forEach((eventTarget) => {
                  eventTarget.handler(...args);
                  if (eventTarget.once) {
                      this.removeListener(eventName, eventTarget.handler);
                  }
              });
          }
          catch (error) {
              console.error(error);
          }
      }
      static once(eventName, listener) {
          this.on(eventName, listener, { once: true });
      }
      static off(eventName, listener) {
          this.removeListener(eventName, listener);
      }
      static removeListener(eventName, listener) {
          if (!(eventName in this._events)) {
              console.warn(`there is no event named ${eventName}`);
              return false;
          }
          let listenerIndex = null;
          for (let i = 0, l = this._events[eventName].length; i < l; i++) {
              if (this._events[eventName][i].handler === listener) {
                  listenerIndex = i;
                  break;
              }
          }
          if (listenerIndex !== null) {
              this._events[eventName].splice(listenerIndex, 1);
          }
      }
      static removeAllListener(eventName) {
          if (this._events[eventName] === undefined) {
              console.warn(`there is no event named ${eventName}`);
              return false;
          }
          this._events[eventName] = [];
      }
      static setMaxListeners(num) {
          this.MAX_LISTENERS = num;
      }
      static clear() {
          this._events = Object.create(null);
      }
  }
  IO._events = Object.create(null);
  IO.MAX_LISTENERS = 200;

  const createDom = (tag) => {
      return document.createElement(tag);
  };
  const createDiv = () => {
      return createDom('div');
  };
  const createSvg = (tag) => {
      return document.createElementNS("http://www.w3.org/2000/svg", tag);
  };

  exports.MouseDownType = void 0;
  (function (MouseDownType) {
      MouseDownType[MouseDownType["LEFT"] = 0] = "LEFT";
      MouseDownType[MouseDownType["RIGHT"] = 2] = "RIGHT";
      MouseDownType[MouseDownType["NONE"] = -1] = "NONE";
  })(exports.MouseDownType || (exports.MouseDownType = {}));
  exports.EditorEventType = void 0;
  (function (EditorEventType) {
      EditorEventType["Normal"] = "normal";
      EditorEventType["NodeSelected"] = "NodeSelected";
      EditorEventType["NodeActive"] = "NodeActive";
  })(exports.EditorEventType || (exports.EditorEventType = {}));
  class BluePrintEditor {
      constructor(container) {
          this.graph = [];
          this.lineGraph = [];
          this.scale = 1;
          this._orginSize = [];
          this._mouseDownType = -1;
          this._mouseDownPosition = [];
          this._translateLast = [0, 0];
          this._transform = {
              translate: [0, 0],
              transformOrigin: '0px 0px',
          };
          this.currentEventType = exports.EditorEventType.Normal;
          IO.emit('beforeCreated');
          IO.on('NodeSelected', () => { });
          IO.on('NodeActive', (node) => {
              this.currentEventType = exports.EditorEventType.NodeActive;
              this.currentTarget = node;
              this._mouseDownPosition[0] = 0;
              this._mouseDownPosition[1] = 0;
              this._mouseDownPosition[2] = node.x;
              this._mouseDownPosition[3] = node.y;
              console.log(this._mouseDownPosition);
          });
          IO.on('NodeInactive', () => {
              this.currentEventType = exports.EditorEventType.Normal;
              this.currentTarget = null;
          });
          IO.on('ConnectPointClick', () => {
          });
          container.oncontextmenu = function () {
              return false;
          };
          this.container = container;
          this._orginSize[0] = this.container.getClientRects()[0].width;
          this._orginSize[1] = this.container.getClientRects()[0].height;
          container.style.position = 'relative';
          container.style.transform = 'scale(1)';
          this.initLineContainer();
          this.init();
      }
      init() {
          this.container.addEventListener('mousedown', (ev) => {
              this.setMouseDownType(ev.button);
              this.recordPosition(ev.clientX, ev.clientY);
              console.log(ev);
          });
          this.container.addEventListener('mouseup', (ev) => {
              this._mouseDownType = -1;
              this._transform.translate = [...this._translateLast];
              this._mouseDownPosition = [];
              IO.emit('mouseup', ev);
          });
          this.container.addEventListener('mousemove', (ev) => {
              IO.emit('mousemove', ev);
              if (this._mouseDownType == exports.MouseDownType.RIGHT) {
                  this.translate(ev);
                  return;
              }
              if (this._mouseDownType == exports.MouseDownType.LEFT &&
                  this.currentEventType == exports.EditorEventType.NodeActive &&
                  this._mouseDownPosition[0] != 0) {
                  this.currentTarget.x =
                      ev.clientX - this._mouseDownPosition[0] + this._mouseDownPosition[2];
                  this.currentTarget.y =
                      ev.clientY - this._mouseDownPosition[1] + this._mouseDownPosition[3];
              }
          });
          this.container.addEventListener('mousewheel', (ev) => {
              this.ScaleHandler(ev);
              this.resize(this.scale);
          });
      }
      add(node) {
          this.container.appendChild(node.container);
          this.graph.push(node);
      }
      addLine(line) {
          this.lineContainer.appendChild(line.instance);
          this.lineGraph.push(line);
      }
      translate(ev) {
          const goalX = ev.clientX - this._mouseDownPosition[0] + this._transform.translate[0];
          const goalY = ev.clientY - this._mouseDownPosition[1] + this._transform.translate[1];
          this.container.style.transform = `translate(${goalX}px, ${goalY}px) scale(${this.scale})`;
          this._translateLast = [goalX, goalY];
      }
      resize(scale) {
          this.container.style.width = this._orginSize[0] * scale + 'px';
          this.container.style.height = this._orginSize[1] * scale + 'px';
      }
      setMouseDownType(type) {
          if (type === 2) {
              this._mouseDownType = 2;
          }
          else if (type === 0) {
              this._mouseDownType = 0;
          }
      }
      recordPosition(x, y) {
          this._mouseDownPosition[0] = x;
          this._mouseDownPosition[1] = y;
      }
      initLineContainer() {
          const svg = createSvg('svg');
          svg.style.width = this.container.getClientRects()[0].width + 'px';
          svg.style.height = this.container.getClientRects()[0].height + 'px';
          svg.style.left = 0;
          svg.style.top = 0;
          this.lineContainer = svg;
          this.container.appendChild(this.lineContainer);
      }
      PreNodeHandler() { }
      ScaleHandler(ev) {
          if (ev.deltaY < 0) {
              this.scale += 0.1;
              this.container.style.transformOrigin = `${ev.x}px ${ev.y}px`;
              this.container.style.transform = `translate(${this._transform.translate[0]}px, ${this._transform.translate[1]}px) scale(${this.scale})`;
          }
          else {
              this.scale -= 0.1;
              this.container.style.transformOrigin = `${ev.x}px ${ev.y}px`;
              this.container.style.transform = `translate(${this._transform.translate[0]}px, ${this._transform.translate[1]}px) scale(${this.scale})`;
          }
      }
  }

  class Node extends BaseNode {
      constructor(params) {
          super();
          this.headerClass = 'wb-container-base-header';
          this.active = false;
          this.nodeName = params.nodeName;
          if (params.headerClass) {
              this.headerClass = params.headerClass;
          }
          if (params.color) {
              this.color = params.color;
          }
          this.initContainer();
          this.initHeader();
          this.initBody();
          this.initPrePoint();
          this.initNextPoint();
          this.container.appendChild(this.header);
          this.container.appendChild(this.body);
          this.leftBody.appendChild(this.prePoint);
          this.rightBody.appendChild(this.nextPoint);
          if (params.input && params.input.length > 0) {
              params.input.forEach((item) => {
                  this.leftBody.appendChild(this.initInput(item.type));
              });
          }
          this.x = params.x || 0;
          this.y = params.y || 0;
      }
      initContainer() {
          const div = createDiv();
          div.className = 'wb-container-base';
          this.container = div;
          this.container.addEventListener('mousedown', () => {
              IO.emit('NodeActive', this);
          });
          this.container.addEventListener('mouseup', () => {
              IO.emit('NodeInactive', this);
          });
      }
      initHeader() {
          const div = createDiv();
          div.className = this.headerClass;
          div.innerText = this.nodeName;
          if (this.color) {
              div.style.backgroundColor = this.color;
          }
          this.header = div;
      }
      initBody() {
          const div = createDiv();
          div.className = 'wb-container-base-body';
          const left = createDiv();
          left.className = 'wb-container-base-body-left';
          const right = createDiv();
          right.className = 'wb-container-base-body-right';
          div.appendChild(left);
          div.appendChild(right);
          this.leftBody = left;
          this.rightBody = right;
          this.body = div;
      }
      initPrePoint() {
          const svg = createSvg('svg');
          svg.setAttribute('class', 'prePoint');
          const polygon = createSvg('polygon');
          polygon.setAttribute('points', '0,0 0,10 5,10 9,5 5,0');
          polygon.setAttribute('stroke-width', '2px');
          polygon.setAttribute('stroke', 'white');
          polygon.setAttribute('fill', 'none');
          svg.appendChild(polygon);
          svg.addEventListener('click', (ev) => {
              IO.emit('ConnectPointClick', this);
          });
          this.prePoint = svg;
      }
      initNextPoint() {
          const svg = createSvg('svg');
          svg.setAttribute('class', 'nextPoint');
          const polygon = createSvg('polygon');
          polygon.setAttribute('points', '0,0 0,10 5,10 9,5 5,0');
          polygon.setAttribute('stroke-width', '2px');
          polygon.setAttribute('stroke', 'white');
          polygon.setAttribute('fill', 'none');
          svg.appendChild(polygon);
          this.nextPoint = svg;
      }
      initInput(type) {
          const svg = createSvg('svg');
          svg.setAttribute('class', 'wb-inputPoint-' + type);
          const circle = createSvg('circle');
          circle.setAttribute('cx', '5');
          circle.setAttribute('cy', '5');
          circle.setAttribute('r', '4');
          circle.setAttribute('stroke-width', '1px');
          circle.setAttribute('fill', 'none');
          const color = this.getColor(type);
          circle.setAttribute('stroke', color);
          svg.appendChild(circle);
          return svg;
      }
      addInput() { }
      getColor(type) {
          let color;
          switch (type) {
              case 'string':
                  color = '#f703cf';
                  break;
              case 'boolean':
                  color = '#8e020b';
                  break;
              case 'object':
                  color = '#20a5e8';
                  break;
              case 'number':
                  color = '#a4fa60';
                  break;
          }
          return color;
      }
      get x() {
          return this._x;
      }
      set x(value) {
          this._x = value;
          this.container.style.left = `${this._x}px`;
      }
      get y() {
          return this._y;
      }
      set y(value) {
          this._y = value;
          this.container.style.top = `${this._y}px`;
      }
  }

  class BaseLine {
      constructor() {
          this.color = 'white';
      }
      _getControlPoint(begin, end) {
          const middlePoint = begin.middileWith(end);
          if (begin.x < end.x) {
              return [middlePoint.x, begin.y, middlePoint.x, end.y];
          }
          else {
              return [
                  begin.x + begin.x - middlePoint.x,
                  begin.y,
                  end.x - (middlePoint.x - end.x),
                  end.y,
              ];
          }
      }
      _setSize() {
          this._width = Math.abs(this._end.x - this._begin.x);
          this._height = Math.abs(this._end.y - this._begin.y);
      }
  }

  class Line extends BaseLine {
      constructor(begin, end) {
          super();
          const cp = this._getControlPoint(begin, end);
          this._begin = begin;
          this._end = end;
          this._setSize();
          const path = `M${begin.x},${begin.y} C${cp[0]},${cp[1]} ${cp[2]},${cp[3]} ${end.x},${end.y}`;
          const Path = createSvg('path');
          Path.setAttribute('stroke-width', '2px');
          Path.setAttribute('stroke', 'white');
          Path.setAttribute('fill', 'none');
          Path.setAttribute('d', path);
          this.instance = Path;
      }
      update() { }
  }

  exports.BaseNode = BaseNode;
  exports.BluePrintEditor = BluePrintEditor;
  exports.Line = Line;
  exports.Node = Node;
  exports.Point = Point;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
