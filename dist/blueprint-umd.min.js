(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.blueprint = {}));
})(this, (function (exports) { 'use strict';

  exports.StaticInputType = void 0;
  (function (StaticInputType) {
      StaticInputType["string"] = "string";
      StaticInputType["number"] = "number";
      StaticInputType["boolean"] = "boolean";
  })(exports.StaticInputType || (exports.StaticInputType = {}));
  class BaseNode {
      constructor() {
          this.inputPoints = [];
          this.outPutPoints = [];
          this.variables = {};
          this.nodeName = 'Function Name';
          this.async = false;
          this._x = 0;
          this._y = 0;
          this.preNode = [];
          this.nextNode = [];
      }
      execute() {
          this.func(this.inputPoints);
          this.nextNode.forEach((item) => {
              item.execute();
          });
      }
  }

  class Point {
      constructor(x, y) {
          this.x = x;
          this.y = y;
      }
  }

  class IO {
      constructor() { }
      static on(eventName, listener, options = {}) {
          if (eventName === undefined || listener === undefined) {
              console.error('event or listener is required!');
              return;
          }
          if (!(eventName in this._events)) {
              this._events[eventName] = [];
          }
          if (this._events[eventName].length >= this.MAX_LISTENERS) {
              console.error(`${eventName}'s number of listeners has reached the limit`);
              return;
          }
          this._events[eventName].push({
              handler: listener,
              once: options.once != undefined ? options.once : false,
          });
      }
      static emit(eventName, ...args) {
          if (!(eventName in this._events)) {
              return false;
          }
          const listeners = this._events[eventName];
          try {
              listeners.forEach((eventTarget) => {
                  eventTarget.handler(...args);
                  if (eventTarget.once) {
                      this.removeListener(eventName, eventTarget.handler);
                  }
              });
          }
          catch (error) {
              console.error(error);
          }
      }
      static once(eventName, listener) {
          this.on(eventName, listener, { once: true });
      }
      static off(eventName, listener) {
          this.removeListener(eventName, listener);
      }
      static removeListener(eventName, listener) {
          if (!(eventName in this._events)) {
              console.warn(`there is no event named ${eventName}`);
              return false;
          }
          let listenerIndex = null;
          for (let i = 0, l = this._events[eventName].length; i < l; i++) {
              if (this._events[eventName][i].handler === listener) {
                  listenerIndex = i;
                  break;
              }
          }
          if (listenerIndex !== null) {
              this._events[eventName].splice(listenerIndex, 1);
          }
      }
      static removeAllListener(eventName) {
          if (this._events[eventName] === undefined) {
              console.warn(`there is no event named ${eventName}`);
              return false;
          }
          this._events[eventName] = [];
      }
      static setMaxListeners(num) {
          this.MAX_LISTENERS = num;
      }
      static clear() {
          this._events = Object.create(null);
      }
  }
  IO._events = Object.create(null);
  IO.MAX_LISTENERS = 200;

  class BluePrintEditor {
      constructor(container) {
          this.scale = 1;
          this._orginSize = [];
          this.container = container;
          this._orginSize[0] = +container.style.width.replace('px', '');
          this._orginSize[0] = +container.style.height.replace('px', '');
          container.style.position = 'relative';
          container.style.transform = 'scale(1)';
          this.container.addEventListener('mouseup', (ev) => {
              IO.emit('mouseup', ev);
          });
          this.container.addEventListener('mousemove', (ev) => {
              IO.emit('mousemove', ev);
          });
          this.container.addEventListener('mousewheel', (ev) => {
              if (ev.deltaY < 0) {
                  this.scale += 0.1;
                  this.container.style.transformOrigin = `${ev.x}px ${ev.y}px`;
                  this.container.style.transform = `scale(${this.scale})`;
              }
              else {
                  this.scale -= 0.1;
                  this.container.style.transformOrigin = `${ev.x}px ${ev.y}px`;
                  this.container.style.transform = `scale(${this.scale})`;
              }
              this.resize(this.scale);
          });
          this.init();
      }
      init() { }
      add(node) {
          this.container.appendChild(node.container);
      }
      addLine(line) {
          this.container.appendChild(line.instance);
      }
      resize(scale) {
          this.container.style.width = this._orginSize[0] * scale + 'px';
          this.container.style.height = this._orginSize[1] * scale + 'px';
      }
  }

  const createDom = (tag) => {
      return document.createElement(tag);
  };
  const createDiv = () => {
      return createDom('div');
  };
  const createSvg = (tag) => {
      return document.createElementNS("http://www.w3.org/2000/svg", tag);
  };

  class Node extends BaseNode {
      constructor(params) {
          super();
          this.headerClass = 'theme-container-base-header';
          this.active = false;
          this.nodeName = params.nodeName;
          if (params.headerClass) {
              this.headerClass = params.headerClass;
          }
          if (params.color) {
              this.color = params.color;
          }
          this.initContainer();
          this.initHeader();
          this.initBody();
          this.initPrePoint();
          this.initNextPoint();
          this.container.appendChild(this.header);
          this.container.appendChild(this.body);
          this.leftBody.appendChild(this.prePoint);
          this.rightBody.appendChild(this.nextPoint);
          if (params.input && params.input.length > 0) {
              params.input.forEach((item) => {
                  this.leftBody.appendChild(this.initInput(item.type));
              });
          }
          this.x = params.x || 0;
          this.y = params.y || 0;
      }
      initContainer() {
          const div = createDiv();
          div.className = 'theme-container-base';
          this.container = div;
      }
      initHeader() {
          const div = createDiv();
          div.className = this.headerClass;
          div.innerText = this.nodeName;
          if (this.color) {
              div.style.backgroundColor = this.color;
          }
          this.header = div;
      }
      initBody() {
          const div = createDiv();
          div.className = 'theme-container-base-body';
          const left = createDiv();
          left.className = 'theme-container-base-body-left';
          const right = createDiv();
          right.className = 'theme-container-base-body-right';
          div.appendChild(left);
          div.appendChild(right);
          this.leftBody = left;
          this.rightBody = right;
          this.body = div;
      }
      initPrePoint() {
          const svg = createSvg('svg');
          svg.setAttribute('class', 'prePoint');
          const polygon = createSvg('polygon');
          polygon.setAttribute('points', '0,0 0,10 5,10 9,5 5,0');
          polygon.setAttribute('stroke-width', '2px');
          polygon.setAttribute('stroke', 'white');
          polygon.setAttribute('fill', 'none');
          svg.appendChild(polygon);
          this.prePoint = svg;
      }
      initNextPoint() {
          const svg = createSvg('svg');
          svg.setAttribute('class', 'nextPoint');
          const polygon = createSvg('polygon');
          polygon.setAttribute('points', '0,0 0,10 5,10 9,5 5,0');
          polygon.setAttribute('stroke-width', '2px');
          polygon.setAttribute('stroke', 'white');
          polygon.setAttribute('fill', 'none');
          svg.appendChild(polygon);
          this.nextPoint = svg;
      }
      initInput(type) {
          const svg = createSvg('svg');
          svg.setAttribute('class', 'theme-inputPoint-' + type);
          const circle = createSvg('circle');
          circle.setAttribute('cx', '5');
          circle.setAttribute('cy', '5');
          circle.setAttribute('r', '4');
          circle.setAttribute('stroke-width', '1px');
          circle.setAttribute('fill', 'none');
          let color;
          switch (type) {
              case 'string':
                  color = '#f703cf';
                  break;
              case 'boolean':
                  color = '#8e020b';
                  break;
              case 'object':
                  color = '#20a5e8';
                  break;
              case 'number':
                  color = '#a4fa60';
                  break;
          }
          circle.setAttribute('stroke', color);
          svg.appendChild(circle);
          return svg;
      }
      addInput() { }
      get x() {
          return this._x;
      }
      set x(value) {
          this._x = value;
          this.container.style.left = `${this._x}px`;
      }
      get y() {
          return this._x;
      }
      set y(value) {
          this._y = value;
          this.container.style.top = `${this._y}px`;
      }
  }

  class BaseLine {
      constructor() {
          this.color = 'white';
      }
      _getControlPoint(begin, end) {
          return [begin.x + 100, begin.y, end.x - 100, end.y];
      }
      _setSize() {
          this._width = Math.abs(this._end.x - this._begin.x);
          this._height = Math.abs(this._end.y - this._begin.y);
      }
  }

  class Line extends BaseLine {
      constructor(begin, end) {
          super();
          const svg = createSvg('svg');
          svg.style.position = 'absolute';
          const cp = this._getControlPoint(begin, end);
          this._begin = begin;
          this._end = end;
          this._setSize();
          const path = `M${2},${2} C${cp[0] - begin.x},${cp[1] - begin.y} ${cp[2] - begin.x},${cp[3] - begin.y} ${this._width + 2},${this._height + 2}`;
          const Path = createSvg('path');
          Path.setAttribute('stroke-width', '2px');
          Path.setAttribute('stroke', 'white');
          Path.setAttribute('fill', 'none');
          Path.setAttribute('d', path);
          svg.style.width = this._width + 4 + 'px';
          svg.style.height = this._height + 4 + 'px';
          svg.style.left = begin.x - 2 + 'px';
          svg.style.top = begin.y - 2 + 'px';
          svg.appendChild(Path);
          this.instance = svg;
      }
      update() { }
  }

  exports.BaseNode = BaseNode;
  exports.BluePrintEditor = BluePrintEditor;
  exports.Line = Line;
  exports.Node = Node;
  exports.Point = Point;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
